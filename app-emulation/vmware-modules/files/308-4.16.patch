diff --git a/vmblock-only/Makefile b/vmblock-only/Makefile
index bbfe225..809fe78 100644
--- a/vmblock-only/Makefile
+++ b/vmblock-only/Makefile
@@ -49,10 +49,10 @@ VM_UNAME = $(shell uname -r)
 ifdef LINUXINCLUDE
 HEADER_DIR = $(LINUXINCLUDE)
 else
-HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
+HEADER_DIR = $(KERNEL_DIR)
 endif
 
-BUILD_DIR = $(HEADER_DIR)/..
+BUILD_DIR = $(KBUILD_OUTPUT)
 
 DRIVER := vmblock
 PRODUCT := ws
diff --git a/vmblock-only/linux/control.c b/vmblock-only/linux/control.c
index 79716bd..40a8f24 100644
--- a/vmblock-only/linux/control.c
+++ b/vmblock-only/linux/control.c
@@ -29,7 +29,7 @@
 #include <linux/stat.h>
 #include <linux/fs.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "vmblockInt.h"
 #include "block.h"
@@ -208,9 +208,11 @@ SetupProcDevice(void)
    VMBlockSetProcEntryOwner(controlProcMountpoint);
 
    /* Create /proc/fs/vmblock/dev */
-   controlProcEntry = create_proc_entry(VMBLOCK_CONTROL_DEVNAME,
-                                        VMBLOCK_CONTROL_MODE,
-                                        controlProcDirEntry);
+   controlProcEntry = proc_create(VMBLOCK_CONTROL_DEVNAME,
+				  VMBLOCK_CONTROL_MODE,
+                                  controlProcDirEntry,
+				  &ControlFileOps);
+
    if (!controlProcEntry) {
       Warning("SetupProcDevice: could not create " VMBLOCK_DEVICE "\n");
       remove_proc_entry(VMBLOCK_CONTROL_MOUNTPOINT, controlProcDirEntry);
@@ -218,7 +220,10 @@ SetupProcDevice(void)
       return -EINVAL;
    }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
    controlProcEntry->proc_fops = &ControlFileOps;
+#endif
+
    return 0;
 }
 
@@ -282,18 +287,24 @@ ExecuteBlockOp(const char __user *buf,                // IN: buffer with name
    int i;
    int retval;
 
-   name = getname(buf);
+   name = __getname();
    if (IS_ERR(name)) {
       return PTR_ERR(name);
    }
 
+   i = strncpy_from_user(name, buf, PATH_MAX);
+   if (i < 0 || i == PATH_MAX) {
+      __putname(name);
+      return -EINVAL;
+   }
+
    for (i = strlen(name) - 1; i >= 0 && name[i] == '/'; i--) {
       name[i] = '\0';
    }
 
    retval = i < 0 ? -EINVAL : blockOp(name, blocker);
 
-   putname(name);
+   __putname(name);
 
    return retval;
 }
diff --git a/vmblock-only/linux/dentry.c b/vmblock-only/linux/dentry.c
index 05ea95a..09ce15b 100644
--- a/vmblock-only/linux/dentry.c
+++ b/vmblock-only/linux/dentry.c
@@ -32,7 +32,11 @@
 #include "block.h"
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 static int DentryOpRevalidate(struct dentry *dentry, struct nameidata *nd);
+#else
+static int DentryOpRevalidate(struct dentry *dentry, unsigned int);
+#endif
 
 struct dentry_operations LinkDentryOps = {
    .d_revalidate = DentryOpRevalidate,
@@ -58,12 +62,15 @@ struct dentry_operations LinkDentryOps = {
  *----------------------------------------------------------------------------
  */
 
-static int
-DentryOpRevalidate(struct dentry *dentry,  // IN: dentry revalidating
-                   struct nameidata *nd)   // IN: lookup flags & intent
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+static int DentryOpRevalidate(struct dentry *dentry, struct nameidata *nd)
+#else
+static int DentryOpRevalidate(struct dentry *dentry, unsigned int flags)
+#endif
+
 {
    VMBlockInodeInfo *iinfo;
-   struct nameidata actualNd;
+   struct path actualNd;
    struct dentry *actualDentry;
    int ret;
 
@@ -101,7 +108,11 @@ DentryOpRevalidate(struct dentry *dentry,  // IN: dentry revalidating
    if (actualDentry &&
        actualDentry->d_op &&
        actualDentry->d_op->d_revalidate) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+      return actualDentry->d_op->d_revalidate(actualDentry, flags);
+#else
       return actualDentry->d_op->d_revalidate(actualDentry, nd);
+#endif
    }
 
    if (compat_path_lookup(iinfo->name, 0, &actualNd)) {
diff --git a/vmblock-only/linux/file.c b/vmblock-only/linux/file.c
index d7ac1f6..c53eb6f 100644
--- a/vmblock-only/linux/file.c
+++ b/vmblock-only/linux/file.c
@@ -38,46 +38,6 @@ typedef u64 inode_num_t;
 typedef ino_t inode_num_t;
 #endif
 
-/* Specifically for our filldir_t callback */
-typedef struct FilldirInfo {
-   filldir_t filldir;
-   void *dirent;
-} FilldirInfo;
-
-
-/*
- *----------------------------------------------------------------------------
- *
- * Filldir --
- *
- *    Callback function for readdir that we use in place of the one provided.
- *    This allows us to specify that each dentry is a symlink, but pass through
- *    everything else to the original filldir function.
- *
- * Results:
- *    Original filldir's return value.
- *
- * Side effects:
- *    Directory information gets copied to user's buffer.
- *
- *----------------------------------------------------------------------------
- */
-
-static int
-Filldir(void *buf,              // IN: Dirent buffer passed from FileOpReaddir
-        const char *name,       // IN: Dirent name
-        int namelen,            // IN: len of dirent's name
-        loff_t offset,          // IN: Offset
-        inode_num_t ino,        // IN: Inode number of dirent
-        unsigned int d_type)    // IN: Type of file
-{
-   FilldirInfo *info = buf;
-
-   /* Specify DT_LNK regardless */
-   return info->filldir(info->dirent, name, namelen, offset, ino, DT_LNK);
-}
-
-
 /* File operations */
 
 /*
@@ -132,7 +92,7 @@ FileOpOpen(struct inode *inode,  // IN
     * and that would try to acquire the inode's semaphore; if the two inodes
     * are the same we'll deadlock.
     */
-   if (actualFile->f_dentry && inode == actualFile->f_dentry->d_inode) {
+   if (actualFile->f_path.dentry && inode == actualFile->f_path.dentry->d_inode) {
       Warning("FileOpOpen: identical inode encountered, open cannot succeed.\n");
       if (filp_close(actualFile, current->files) < 0) {
          Warning("FileOpOpen: unable to close opened file.\n");
@@ -166,11 +126,9 @@ FileOpOpen(struct inode *inode,  // IN
 
 static int
 FileOpReaddir(struct file *file,  // IN
-              void *dirent,       // IN
-              filldir_t filldir)  // IN
+		struct dir_context *ctx)
 {
    int ret;
-   FilldirInfo info;
    struct file *actualFile;
 
    if (!file) {
@@ -184,11 +142,8 @@ FileOpReaddir(struct file *file,  // IN
       return -EINVAL;
    }
 
-   info.filldir = filldir;
-   info.dirent = dirent;
-
    actualFile->f_pos = file->f_pos;
-   ret = vfs_readdir(actualFile, Filldir, &info);
+   ret = iterate_dir(actualFile, ctx);
    file->f_pos = actualFile->f_pos;
 
    return ret;
@@ -237,7 +192,7 @@ FileOpRelease(struct inode *inode, // IN
 
 
 struct file_operations RootFileOps = {
-   .readdir = FileOpReaddir,
+   .iterate = FileOpReaddir,
    .open    = FileOpOpen,
    .release = FileOpRelease,
 };
diff --git a/vmblock-only/linux/filesystem.c b/vmblock-only/linux/filesystem.c
index af57499..931fad0 100644
--- a/vmblock-only/linux/filesystem.c
+++ b/vmblock-only/linux/filesystem.c
@@ -322,7 +322,7 @@ Iget(struct super_block *sb,    // IN: file system superblock object
 {
    VMBlockInodeInfo *iinfo;
    struct inode *inode;
-   struct nameidata actualNd;
+   struct path actualNd;
 
    ASSERT(sb);
 
diff --git a/vmblock-only/linux/inode.c b/vmblock-only/linux/inode.c
index 098c94c..e425a3b 100644
--- a/vmblock-only/linux/inode.c
+++ b/vmblock-only/linux/inode.c
@@ -28,6 +28,8 @@
 #include <linux/fs.h>
 #include <linux/time.h>
 #include <linux/namei.h>
+#include <linux/cred.h>
+#include <linux/iversion.h>
 
 #include "vmblockInt.h"
 #include "filesystem.h"
@@ -35,10 +37,20 @@
 
 
 /* Inode operations */
-static struct dentry *InodeOpLookup(struct inode *dir,
-                                    struct dentry *dentry, struct nameidata *nd);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+static struct dentry *InodeOpLookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd);
 static int InodeOpReadlink(struct dentry *dentry, char __user *buffer, int buflen);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+#else
+static struct dentry *InodeOpLookup(struct inode *, struct dentry *, unsigned int);
+static int InodeOpReadlink(struct dentry *, char __user *, int);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 99)
+static const char *InodeOpFollowlink(struct dentry *dentry, struct inode *inode, struct delayed_call *done);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 99)
+static const char *InodeOpFollowlink(struct dentry *dentry, void **cookie);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
 static void *InodeOpFollowlink(struct dentry *dentry, struct nameidata *nd);
 #else
 static int InodeOpFollowlink(struct dentry *dentry, struct nameidata *nd);
@@ -49,12 +61,19 @@ struct inode_operations RootInodeOps = {
    .lookup = InodeOpLookup,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
 static struct inode_operations LinkInodeOps = {
+#else
+struct inode_operations LinkInodeOps = {
+#endif
    .readlink    = InodeOpReadlink,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 99)
+   .get_link = InodeOpFollowlink,
+#else
    .follow_link = InodeOpFollowlink,
+#endif
 };
 
-
 /*
  *----------------------------------------------------------------------------
  *
@@ -75,7 +94,11 @@ static struct inode_operations LinkInodeOps = {
 static struct dentry *
 InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
               struct dentry *dentry,  // IN: dentry to lookup
-              struct nameidata *nd)   // IN: lookup intent and information
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	      struct nameidata *nd)   // IN: lookup intent and information
+#else
+              unsigned int flags)
+#endif
 {
    char *filename;
    struct inode *inode;
@@ -133,9 +156,14 @@ InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
 
    inode->i_mode = S_IFLNK | S_IRWXUGO;
    inode->i_size = INODE_TO_IINFO(inode)->nameLen;
-   inode->i_version = 1;
-   inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+   inode_set_iversion_raw(inode, 1);
+   inode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
    inode->i_uid = inode->i_gid = 0;
+#else
+   inode->i_gid = make_kgid(current_user_ns(), 0);
+   inode->i_uid = make_kuid(current_user_ns(), 0);
+#endif
    inode->i_op = &LinkInodeOps;
 
    d_add(dentry, inode);
@@ -177,7 +205,15 @@ InodeOpReadlink(struct dentry *dentry,  // IN : dentry of symlink
       return -EINVAL;
    }
 
-   return vfs_readlink(dentry, buffer, buflen, iinfo->name);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 14, 99)
+	return vfs_readlink(dentry, buffer, buflen, iinfo->name);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(4, 6, 99)
+    return readlink_copy(buffer, buflen, iinfo->name);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(4, 9, 99)
+    return generic_readlink(dentry, buffer, buflen);
+#else
+    return vfs_readlink(dentry, buffer, buflen);
+#endif
 }
 
 
@@ -198,30 +234,53 @@ InodeOpReadlink(struct dentry *dentry,  // IN : dentry of symlink
  *----------------------------------------------------------------------------
  */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 99)
+static const char *
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
 static void *
 #else
 static int
 #endif
 InodeOpFollowlink(struct dentry *dentry,  // IN : dentry of symlink
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 99)
+                  struct inode *inode,
+                  struct delayed_call *done)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 99)
+                  void **cookie)          // OUT: stores opaque pointer
+#else
                   struct nameidata *nd)   // OUT: stores result
+#endif
 {
    int ret;
    VMBlockInodeInfo *iinfo;
 
    if (!dentry) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 99)
+      ret = -ECHILD;
+#else
       Warning("InodeOpReadlink: invalid args from kernel\n");
       ret = -EINVAL;
+#endif
       goto out;
    }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 99)
+   iinfo = INODE_TO_IINFO(inode);
+#else
    iinfo = INODE_TO_IINFO(dentry->d_inode);
+#endif
    if (!iinfo) {
       ret = -EINVAL;
       goto out;
    }
 
-   ret = vfs_follow_link(nd, iinfo->name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 99)
+   return iinfo->name;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 99)
+   return *cookie = iinfo->name;
+#else
+   nd_set_link(nd, iinfo->name);
+#endif
 
 out:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
diff --git a/vmblock-only/shared/compat_namei.h b/vmblock-only/shared/compat_namei.h
index f82dd49..f52d03a 100644
--- a/vmblock-only/shared/compat_namei.h
+++ b/vmblock-only/shared/compat_namei.h
@@ -21,26 +21,41 @@
 
 #include <linux/namei.h>
 
+#if 0
+/* Copy-n-paste from kernel's source/fs/namei.c */
+struct nameidata {
+         struct path     path;
+         struct qstr     last;
+         struct path     root;
+         struct inode    *inode; /* path.dentry.d_inode */
+         unsigned int    flags;
+         unsigned        seq, m_seq;
+         int             last_type;
+         unsigned        depth;
+         struct file     *base;
+         char *saved_names[MAX_NESTED_LINKS + 1];
+};
+#endif
 /*
  * In 2.6.25-rc2, dentry and mount objects were removed from the nameidata
  * struct. They were both replaced with a struct path.
  */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-#define compat_vmw_nd_to_dentry(nd) (nd).path.dentry
+#define compat_vmw_nd_to_dentry(nd) (nd).dentry
 #else
 #define compat_vmw_nd_to_dentry(nd) (nd).dentry
 #endif
 
 /* In 2.6.25-rc2, path_release(&nd) was replaced with path_put(&nd.path). */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-#define compat_path_release(nd) path_put(&(nd)->path)
+#define compat_path_release(nd) path_put(nd)
 #else
 #define compat_path_release(nd) path_release(nd)
 #endif
 
 /* path_lookup was removed in 2.6.39 merge window VFS merge */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
-#define compat_path_lookup(name, flags, nd)     kern_path(name, flags, &((nd)->path))
+#define compat_path_lookup(name, flags, nd)     kern_path(name, flags, nd)
 #else
 #define compat_path_lookup(name, flags, nd)     path_lookup(name, flags, nd)
 #endif
diff --git a/vmblock-only/shared/compat_uaccess.h b/vmblock-only/shared/compat_uaccess.h
index d58ee05..641bd2b 100644
--- a/vmblock-only/shared/compat_uaccess.h
+++ b/vmblock-only/shared/compat_uaccess.h
@@ -21,7 +21,9 @@
 
 
 /* User space access functions moved in 2.1.7 to asm/uaccess.h --hpreg */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 1, 7)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#   include <linux/uaccess.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 1, 7)
 #   include <asm/uaccess.h>
 #else
 #   include <asm/segment.h>
diff --git a/vmci-only/Makefile b/vmci-only/Makefile
index c630705..6b34b54 100644
--- a/vmci-only/Makefile
+++ b/vmci-only/Makefile
@@ -49,10 +49,10 @@ VM_UNAME = $(shell uname -r)
 ifdef LINUXINCLUDE
 HEADER_DIR = $(LINUXINCLUDE)
 else
-HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
+HEADER_DIR = $(KERNEL_DIR)
 endif
 
-BUILD_DIR = $(HEADER_DIR)/..
+BUILD_DIR = $(KBUILD_OUTPUT)
 
 DRIVER := vmci
 PRODUCT := ws
diff --git a/vmci-only/linux/driver.c b/vmci-only/linux/driver.c
index 1da7ab7..5f4c3cc 100644
--- a/vmci-only/linux/driver.c
+++ b/vmci-only/linux/driver.c
@@ -37,6 +37,8 @@ sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
 #include <linux/moduleparam.h>
 #include <linux/poll.h>
 #include <linux/smp.h>
+#include <linux/vmalloc.h>
+#include <linux/cred.h>
 
 #include "compat_highmem.h"
 #include "compat_interrupt.h"
@@ -1466,7 +1468,9 @@ VMCIUserVALockPage(VA addr) // IN:
    int retval;
 
    down_read(&current->mm->mmap_sem);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+   retval = get_user_pages(addr, 1, FOLL_WRITE, &page, NULL);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
    retval = get_user_pages(addr, 1, 1, 0, &page, NULL);
 #else
    retval = get_user_pages(current, current->mm, addr,
@@ -1722,11 +1726,11 @@ vmci_enable_msix(struct pci_dev *pdev) // IN
       vmci_dev.msix_entries[i].vector = i;
    }
 
-   result = pci_enable_msix(pdev, vmci_dev.msix_entries, VMCI_MAX_INTRS);
+   result = pci_enable_msix_exact(pdev, vmci_dev.msix_entries, VMCI_MAX_INTRS);
    if (!result) {
       vmci_dev.exclusive_vectors = TRUE;
-   } else if (result > 0) {
-      result = pci_enable_msix(pdev, vmci_dev.msix_entries, 1);
+   } else {
+      result = pci_enable_msix_exact(pdev, vmci_dev.msix_entries, 1);
    }
    return result;
 }
@@ -2469,8 +2473,6 @@ vmci_init(void)
 static void __exit
 vmci_exit(void)
 {
-   int retval;
-
    if (guestDeviceInit) {
       pci_unregister_driver(&vmci_driver);
       vfree(data_buffer);
@@ -2482,12 +2484,8 @@ vmci_exit(void)
 
       VMCI_HostCleanup();
 
-      retval = misc_deregister(&linuxState.misc);
-      if (retval) {
-         Warning(LGPFX "Module %s: error unregistering\n", VMCI_MODULE_NAME);
-      } else {
-         Log(LGPFX"Module %s: unloaded\n", VMCI_MODULE_NAME);
-      }
+      misc_deregister(&linuxState.misc);
+      Log(LGPFX"Module %s: unloaded\n", VMCI_MODULE_NAME);
 
       hostDeviceInit = FALSE;
    }
diff --git a/vmci-only/linux/vmciKernelIf.c b/vmci-only/linux/vmciKernelIf.c
index 3fba8b6..241b26c 100644
--- a/vmci-only/linux/vmciKernelIf.c
+++ b/vmci-only/linux/vmciKernelIf.c
@@ -40,6 +40,8 @@
 #include <linux/socket.h>       /* For memcpy_{to,from}iovec(). */
 #include <linux/vmalloc.h>
 #include <linux/wait.h>
+#include <linux/skbuff.h>
+#include <linux/sched/signal.h>
 
 #include "compat_highmem.h"
 #include "compat_interrupt.h"
@@ -1196,21 +1198,21 @@ __VMCIMemcpyToQueue(VMCIQueue *queue,   // OUT:
       } else {
          toCopy = size - bytesCopied;
       }
-
+      /* Code cloned from kernels drivers/misc/vmw_vmci/vmci_queue_pair.c */
       if (isIovec) {
-         struct iovec *iov = (struct iovec *)src;
+         struct msghdr *msg = (struct msghdr *)src;
          int err;
 
-         /* The iovec will track bytesCopied internally. */
-         err = memcpy_fromiovec((uint8 *)va + pageOffset, iov, toCopy);
+         /* The iovec will track bytes_copied internally. */
+         err = memcpy_from_msg((u8 *)va + pageOffset, msg, toCopy);
          if (err != 0) {
-            if (kernelIf->host) {
+            if (kernelIf->host)
                kunmap(kernelIf->u.h.page[pageIndex]);
-            }
             return VMCI_ERROR_INVALID_ARGS;
          }
       } else {
-         memcpy((uint8 *)va + pageOffset, (uint8 *)src + bytesCopied, toCopy);
+            memcpy((u8 *)va + pageOffset,
+                   (u8 *)src + bytesCopied, toCopy);
       }
 
       bytesCopied += toCopy;
@@ -1273,11 +1275,11 @@ __VMCIMemcpyFromQueue(void *dest,             // OUT:
       }
 
       if (isIovec) {
-         struct iovec *iov = (struct iovec *)dest;
+	  struct msghdr *msg = (struct msghdr *)dest;
          int err;
 
          /* The iovec will track bytesCopied internally. */
-         err = memcpy_toiovec(iov, (uint8 *)va + pageOffset, toCopy);
+	  err = memcpy_to_msg(msg, (uint8 *)va + pageOffset, toCopy);
          if (err != 0) {
             if (kernelIf->host) {
                kunmap(kernelIf->u.h.page[pageIndex]);
@@ -1834,7 +1836,11 @@ VMCIReleasePages(struct page **pages,  // IN
       if (dirty) {
          set_page_dirty(pages[i]);
       }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 99)
+      put_page(pages[i]);
+#else
       page_cache_release(pages[i]);
+#endif
       pages[i] = NULL;
    }
 }
@@ -2051,7 +2057,11 @@ VMCIHost_GetUserMemory(VA64 produceUVA,       // IN
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
    retval = get_user_pages((VA)produceUVA,
                            produceQ->kernelIf->numPages,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+                           FOLL_WRITE,
+#else
                            1, 0,
+#endif
                            produceQ->kernelIf->u.h.headerPage,
                            NULL);
 #else
@@ -2070,11 +2080,19 @@ VMCIHost_GetUserMemory(VA64 produceUVA,       // IN
       goto out;
    }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 99)
+   retval = get_user_pages((VA)consumeUVA,
+#else
    retval = get_user_pages(current,
                            current->mm,
                            (VA)consumeUVA,
+#endif
                            consumeQ->kernelIf->numPages,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+                           FOLL_WRITE,
+#else
                            1, 0,
+#endif
                            consumeQ->kernelIf->u.h.headerPage,
                            NULL);
    if (retval < consumeQ->kernelIf->numPages) {
diff --git a/vmci-only/shared/compat_uaccess.h b/vmci-only/shared/compat_uaccess.h
index d58ee05..641bd2b 100644
--- a/vmci-only/shared/compat_uaccess.h
+++ b/vmci-only/shared/compat_uaccess.h
@@ -21,7 +21,9 @@
 
 
 /* User space access functions moved in 2.1.7 to asm/uaccess.h --hpreg */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 1, 7)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#   include <linux/uaccess.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 1, 7)
 #   include <asm/uaccess.h>
 #else
 #   include <asm/segment.h>
diff --git a/vmci-only/shared/vm_basic_defs.h b/vmci-only/shared/vm_basic_defs.h
index efe492a..1db0301 100644
--- a/vmci-only/shared/vm_basic_defs.h
+++ b/vmci-only/shared/vm_basic_defs.h
@@ -720,6 +720,7 @@ typedef int pid_t;
                                                      lfMessageFont)
 
 /* This is not intended to be thread-safe. */
+#ifndef DO_ONCE
 #define DO_ONCE(code)                                                   \
    do {                                                                 \
       static Bool _doOnceDone = FALSE;                                  \
@@ -728,6 +729,7 @@ typedef int pid_t;
          code;                                                          \
       }                                                                 \
    } while (0)
+#endif
 
 /*
  * Bug 827422 and 838523.
diff --git a/vmci-only/shared/vm_device_version.h b/vmci-only/shared/vm_device_version.h
index e2cb477..51a7ead 100644
--- a/vmci-only/shared/vm_device_version.h
+++ b/vmci-only/shared/vm_device_version.h
@@ -53,7 +53,9 @@
  *    VMware HD Audio codec
  *    VMware HD Audio controller
  */
+#ifndef PCI_VENDOR_ID_VMWARE
 #define PCI_VENDOR_ID_VMWARE                    0x15AD
+#endif
 #define PCI_DEVICE_ID_VMWARE_SVGA2              0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA               0x0710
 #define PCI_DEVICE_ID_VMWARE_VGA                0x0711
@@ -70,7 +72,9 @@
 #define PCI_DEVICE_ID_VMWARE_1394               0x0780
 #define PCI_DEVICE_ID_VMWARE_BRIDGE             0x0790
 #define PCI_DEVICE_ID_VMWARE_ROOTPORT           0x07A0
+#ifndef PCI_DEVICE_ID_VMWARE_VMXNET3
 #define PCI_DEVICE_ID_VMWARE_VMXNET3            0x07B0
+#endif
 #define PCI_DEVICE_ID_VMWARE_PVSCSI             0x07C0
 #define PCI_DEVICE_ID_VMWARE_82574              0x07D0
 #define PCI_DEVICE_ID_VMWARE_AHCI               0x07E0
diff --git a/vmmon-only/Makefile b/vmmon-only/Makefile
index de8162e..f486ccb 100644
--- a/vmmon-only/Makefile
+++ b/vmmon-only/Makefile
@@ -49,10 +49,10 @@ VM_UNAME = $(shell uname -r)
 ifdef LINUXINCLUDE
 HEADER_DIR = $(LINUXINCLUDE)
 else
-HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
+HEADER_DIR = $(KERNEL_DIR)
 endif
 
-BUILD_DIR = $(HEADER_DIR)/..
+BUILD_DIR = $(KBUILD_OUTPUT)
 
 DRIVER := vmmon
 PRODUCT := @@PRODUCT@@
diff --git a/vmmon-only/common/task.c b/vmmon-only/common/task.c
index 228996e..545184e 100644
--- a/vmmon-only/common/task.c
+++ b/vmmon-only/common/task.c
@@ -1594,12 +1594,23 @@ TaskSwitchToMonitor(VMCrossPage *crosspage)
    {
       uint64 raxGetsWiped, rcxGetsWiped;
 
+#ifdef CALL_NOSPEC
+      __asm__ __volatile__(CALL_NOSPEC
+                           : "=a" (raxGetsWiped),
+                             "=c" (rcxGetsWiped)
+                           : "0" (codePtr),
+                             "1" (crosspage),
+                             THUNK_TARGET(codePtr)
+                           : "rdx", "r8", "r9", "r10", "r11", "cc", "memory");
+#else
       __asm__ __volatile__("call *%%rax"
                            : "=a" (raxGetsWiped),
                              "=c" (rcxGetsWiped)
                            : "0" (codePtr),
                              "1" (crosspage)
                            : "rdx", "r8", "r9", "r10", "r11", "cc", "memory");
+#endif
+
    }
 #elif defined(_MSC_VER)
    /*
diff --git a/vmmon-only/include/compat_timer.h b/vmmon-only/include/compat_timer.h
new file mode 100644
index 0000000..5faeab1
--- /dev/null
+++ b/vmmon-only/include/compat_timer.h
@@ -0,0 +1,33 @@
+#ifndef __COMPAT_TIMER_H__
+#   define __COMPAT_TIMER_H__
+
+#include <linux/timer.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)) && !defined(timer_setup)
+
+typedef unsigned long compat_timer_arg_t;
+
+static inline void compat_timer_setup(struct timer_list *timer,
+				      void (*func)(compat_timer_arg_t),
+				      unsigned int flags)
+{
+	init_timer(timer);
+	timer->function = func;
+	timer->data = 0;
+	timer->flags = flags;
+}
+
+#else /* new timer interface since 4.15 */
+
+typedef struct timer_list *compat_timer_arg_t;
+
+static inline void compat_timer_setup(struct timer_list *timer,
+				      void (*func)(compat_timer_arg_t),
+				      unsigned int flags)
+{
+	timer_setup(timer, func, flags);
+}
+
+#endif /* new timer interface since 4.15 */
+
+#endif /* __COMPAT_TIMER_H__ */
diff --git a/vmmon-only/include/vm_assert.h b/vmmon-only/include/vm_assert.h
index b368e1d..0ad4115 100644
--- a/vmmon-only/include/vm_assert.h
+++ b/vmmon-only/include/vm_assert.h
@@ -67,6 +67,7 @@ extern "C" {
 #if defined (VMKPANIC) 
 #include "vmk_assert.h"
 #else /* !VMKPANIC */
+#include <linux/kernel.h>
 #define _ASSERT_PANIC(name) \
            Panic(_##name##Fmt "\n", __FILE__, __LINE__)
 #define _ASSERT_PANIC_BUG(bug, name) \
@@ -118,7 +119,7 @@ NORETURN void Panic_NoSaveNoReturn(const char *fmt, ...) PRINTF_DECL(1, 2);
 } while(0)
 
 #else
-NORETURN void Panic(const char *fmt, ...) PRINTF_DECL(1, 2);
+#define Panic panic
 #endif
 
 void LogThrottled(uint32 *count, const char *fmt, ...) PRINTF_DECL(2, 3);
diff --git a/vmmon-only/include/x86_basic_defs.h b/vmmon-only/include/x86_basic_defs.h
index 7a5ba99..8a735bb 100644
--- a/vmmon-only/include/x86_basic_defs.h
+++ b/vmmon-only/include/x86_basic_defs.h
@@ -35,6 +35,8 @@
 #define INCLUDE_ALLOW_VMCORE
 #include "includeCheck.h"
 
+#include <asm/processor-flags.h>
+
 #define X86_MAX_INSTR_LEN  15   /* Max byte length of an x86 instruction. */
 
 #define NUM_IDT_VECTORS 256
@@ -62,7 +64,9 @@
 #define CR3_PDB_MASK   0xfffff000
 #define CR3_IGNORE     0xFFF
 #define PAE_CR3_IGNORE 0x1F
+#ifndef CR3_PCID_MASK
 #define CR3_PCID_MASK  0xFFF
+#endif
 #define CR3_NO_FLUSH   (1ULL << 63)
 
 #define CR4_VME        0x00000001
diff --git a/vmmon-only/include/x86msr.h b/vmmon-only/include/x86msr.h
index e1675bd..a4dbd1b 100644
--- a/vmmon-only/include/x86msr.h
+++ b/vmmon-only/include/x86msr.h
@@ -24,6 +24,7 @@
 
 #ifndef _X86MSR_H_
 #define _X86MSR_H_
+#include <asm/msr-index.h>
 #define INCLUDE_ALLOW_USERLEVEL
 #define INCLUDE_ALLOW_VMX
 
@@ -106,7 +107,9 @@ MSRQuery;
 #define MSR_TSC_AUX           0xc0000103
 #define MSR_BD_TSC_RATIO      0xc0000104
 
+#ifndef MSR_MISC_FEATURES_ENABLES
 #define MSR_MISC_FEATURES_ENABLES            0x140
+#endif
 
 /* Intel Core Architecture and later: use only architected counters. */
 #define IA32_MSR_PERF_CAPABILITIES                0x345
@@ -300,7 +303,9 @@ typedef enum {
 #define MSR_K7_HWCR_SSEDIS         0x00008000ULL // Disable SSE bit
 #define MSR_K7_HWCR_MONMWAITUSEREN 0x00000400ULL // Enable MONITOR/MWAIT CPL>0
 #define MSR_K7_HWCR_TLBFFDIS       0x00000040ULL // Disable TLB Flush Filter
+#ifndef MSR_K7_HWCR_SMMLOCK
 #define MSR_K7_HWCR_SMMLOCK        0x00000001ULL // Lock SMM environment
+#endif
 
 #ifndef MSR_K8_SYSCFG
 #define MSR_K8_SYSCFG        0xc0010010
@@ -475,7 +480,11 @@ typedef enum {
 /*
  * MISC_FEATURES_ENABLES bits
  */
+#ifdef MSR_MISC_FEATURES_ENABLES_CPUID_FAULT
+#define MSR_MISC_FEATURES_ENABLES_CPUID_FAULTING MSR_MISC_FEATURES_ENABLES_CPUID_FAULT
+#else
 #define MSR_MISC_FEATURES_ENABLES_CPUID_FAULTING 1
+#endif
 
 
 
diff --git a/vmmon-only/linux/driver.c b/vmmon-only/linux/driver.c
index 3595237..f623980 100644
--- a/vmmon-only/linux/driver.c
+++ b/vmmon-only/linux/driver.c
@@ -21,6 +21,7 @@
 
 #define EXPORT_SYMTAB
 
+#include "compat_timer.h"
 #include <linux/file.h>
 #include <linux/highmem.h>
 #include <linux/poll.h>
@@ -115,7 +116,7 @@ static struct page *LinuxDriverNoPage(struct vm_area_struct *vma,
 #endif
 static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
 
-static void LinuxDriverPollTimeout(unsigned long clientData);
+static void LinuxDriverPollTimeout(compat_timer_arg_t unused);
 static unsigned int LinuxDriverEstimateTSCkHz(void);
 
 static struct vm_operations_struct vmuser_mops = {
@@ -126,7 +127,16 @@ static struct vm_operations_struct vmuser_mops = {
 #endif
 };
 
-static struct file_operations vmuser_fops;
+static struct file_operations vmuser_fops = {
+   .owner = THIS_MODULE,
+   .poll = LinuxDriverPoll,
+   .unlocked_ioctl = LinuxDriver_Ioctl,
+   .compat_ioctl = LinuxDriver_Ioctl,
+   .open = LinuxDriver_Open,
+   .release = LinuxDriver_Close,
+   .mmap = LinuxDriverMmap
+};
+
 static struct timer_list tscTimer;
 static Atomic_uint32 tsckHz;
 static VmTimeStart tsckHzStartTime;
@@ -227,7 +237,7 @@ LinuxDriverEstimateTSCkHz(void)
  *----------------------------------------------------------------------
  */
 static void
-LinuxDriverEstimateTSCkHzDeferred(unsigned long data)
+LinuxDriverEstimateTSCkHzDeferred(compat_timer_arg_t unused)
 {
    LinuxDriverEstimateTSCkHz();
 }
@@ -265,9 +275,7 @@ LinuxDriverInitTSCkHz(void)
    }
 
    Vmx86_ReadTSCAndUptime(&tsckHzStartTime);
-   tscTimer.function = LinuxDriverEstimateTSCkHzDeferred;
    tscTimer.expires  = jiffies + 4 * HZ;
-   tscTimer.data     = 0;
    add_timer(&tscTimer);
 }
 
@@ -309,9 +317,7 @@ init_module(void)
     */
 
    init_waitqueue_head(&linuxState.pollQueue);
-   init_timer(&linuxState.pollTimer);
-   linuxState.pollTimer.data = 0;
-   linuxState.pollTimer.function = LinuxDriverPollTimeout;
+   compat_timer_setup(&linuxState.pollTimer, LinuxDriverPollTimeout, 0);
 
    linuxState.fastClockThread = NULL;
    linuxState.fastClockFile = NULL;
@@ -319,21 +325,6 @@ init_module(void)
    linuxState.fastClockPriority = -20;
    linuxState.swapSize = VMMON_UNKNOWN_SWAP_SIZE;
 
-   /*
-    * Initialize the file_operations structure. Because this code is always
-    * compiled as a module, this is fine to do it here and not in a static
-    * initializer.
-    */
-
-   memset(&vmuser_fops, 0, sizeof vmuser_fops);
-   vmuser_fops.owner = THIS_MODULE;
-   vmuser_fops.poll = LinuxDriverPoll;
-   vmuser_fops.unlocked_ioctl = LinuxDriver_Ioctl;
-   vmuser_fops.compat_ioctl = LinuxDriver_Ioctl;
-   vmuser_fops.open = LinuxDriver_Open;
-   vmuser_fops.release = LinuxDriver_Close;
-   vmuser_fops.mmap = LinuxDriverMmap;
-
 #ifdef VMX86_DEVEL
    devel_init_module();
    linuxState.minor = 0;
@@ -360,7 +351,7 @@ init_module(void)
        linuxState.deviceName, linuxState.major, linuxState.minor);
 
    HostIF_InitUptime();
-   init_timer(&tscTimer);
+   compat_timer_setup(&tscTimer, LinuxDriverEstimateTSCkHzDeferred, 0);
    LinuxDriverInitTSCkHz();
    Vmx86_InitIDList();
 
@@ -858,7 +849,7 @@ LinuxDriverPoll(struct file *filp,  // IN:
  */
 
 static void
-LinuxDriverPollTimeout(unsigned long clientData)  // IN:
+LinuxDriverPollTimeout(compat_timer_arg_t unused)  // IN:
 {
    LinuxDriverWakeUp(FALSE);
 }
@@ -1287,7 +1278,7 @@ LinuxDriverReadTSC(void *data,   // OUT: TSC values
  *-----------------------------------------------------------------------------
  */
 
-__attribute__((always_inline)) static Bool
+__always_inline static Bool
 LinuxDriverSyncReadTSCs(uint64 *delta) // OUT: TSC max - TSC min
 {
    TSCDelta tscDelta;
diff --git a/vmmon-only/linux/hostif.c b/vmmon-only/linux/hostif.c
index 80b5787..908224d 100644
--- a/vmmon-only/linux/hostif.c
+++ b/vmmon-only/linux/hostif.c
@@ -30,6 +30,7 @@
 
 /* Must come before vmware.h --hpreg */
 #include "compat_page.h"
+#include "compat_timer.h"
 #include <linux/binfmts.h>
 #include <linux/delay.h>
 #include <linux/file.h>
@@ -99,6 +100,37 @@
 #include "vmmonInt.h"
 #include "versioned_atomic.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#   define global_zone_page_state global_page_state
+#endif
+
+static unsigned long get_nr_slab_unreclaimable(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+   return global_node_page_state(NR_SLAB_UNRECLAIMABLE);
+#else
+   return global_page_state(NR_SLAB_UNRECLAIMABLE);
+#endif
+}
+
+static unsigned long get_nr_unevictable(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+   return global_node_page_state(NR_UNEVICTABLE);
+#else
+   return global_page_state(NR_UNEVICTABLE);
+#endif
+}
+
+static unsigned long get_nr_anon_mapped(void)
+{
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+   return global_node_page_state(NR_ANON_MAPPED);
+ #else
+   return global_page_state(NR_ANON_PAGES);
+ #endif
+}
+
 /*
  * Determine if we can use high resolution timers.
  */
@@ -1594,16 +1626,11 @@ HostIF_EstimateLockedPageLimit(const VMDriver* vm,                // IN
    unsigned int reservedPages = MEMDEFAULTS_MIN_HOST_PAGES;
    unsigned int hugePages = (vm == NULL) ? 0 :
       BYTES_2_PAGES(vm->memInfo.hugePageBytes);
-   unsigned int lockedPages = global_page_state(NR_PAGETABLE) +
-                              global_page_state(NR_SLAB_UNRECLAIMABLE) +
-                              global_page_state(NR_UNEVICTABLE) +
+   unsigned int lockedPages = global_zone_page_state(NR_PAGETABLE) +
+                              get_nr_slab_unreclaimable() +
+                              get_nr_unevictable() +
                               hugePages + reservedPages;
-   unsigned int anonPages =
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
-      global_page_state(NR_ANON_MAPPED);
-#else
-      global_page_state(NR_ANON_PAGES);
-#endif
+   unsigned int anonPages = get_nr_anon_mapped();
    unsigned int swapPages = BYTES_2_PAGES(linuxState.swapSize);
 
    if (anonPages > swapPages) {
@@ -1767,7 +1794,7 @@ HostIFReadUptimeWork(unsigned long *j)  // OUT: current jiffies
  */
 
 static void
-HostIFUptimeResyncMono(unsigned long data)  // IN: ignored
+HostIFUptimeResyncMono(compat_timer_arg_t unused)  // IN: ignored
 {
    unsigned long jifs;
    uintptr_t flags;
@@ -1829,8 +1856,7 @@ HostIF_InitUptime(void)
                   -(tv.tv_usec * (UPTIME_FREQ / 1000000) + 
                     tv.tv_sec * UPTIME_FREQ));
 
-   init_timer(&uptimeState.timer);
-   uptimeState.timer.function = HostIFUptimeResyncMono;
+   compat_timer_setup(&uptimeState.timer, HostIFUptimeResyncMono, 0);
    mod_timer(&uptimeState.timer, jiffies + HZ);
 }
 
diff --git a/vmnet-only/Makefile b/vmnet-only/Makefile
index 459846e..0a4cdb0 100644
--- a/vmnet-only/Makefile
+++ b/vmnet-only/Makefile
@@ -49,10 +49,10 @@ VM_UNAME = $(shell uname -r)
 ifdef LINUXINCLUDE
 HEADER_DIR = $(LINUXINCLUDE)
 else
-HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
+HEADER_DIR = $(KERNEL_DIR)
 endif
 
-BUILD_DIR = $(HEADER_DIR)/..
+BUILD_DIR = $(KBUILD_OUTPUT)
 
 DRIVER := vmnet
 PRODUCT := @@PRODUCT@@
diff --git a/vmnet-only/bridge.c b/vmnet-only/bridge.c
index 8cdaf11..c569054 100644
--- a/vmnet-only/bridge.c
+++ b/vmnet-only/bridge.c
@@ -636,7 +636,7 @@ VNetBridgeReceiveFromVNet(VNetJack        *this, // IN: jack
 	 unsigned long flags;
 	 int i;
 
-	 atomic_inc(&clone->users);
+	 clone = skb_get(clone);
 
 	 clone->dev = dev;
 	 clone->protocol = eth_type_trans(clone, dev);
diff --git a/vmnet-only/driver.c b/vmnet-only/driver.c
index 7e7ad99..c154d64 100644
--- a/vmnet-only/driver.c
+++ b/vmnet-only/driver.c
@@ -137,7 +137,16 @@ static ssize_t  VNetFileOpWrite(struct file *filp, const char *buf, size_t count
 static long  VNetFileOpUnlockedIoctl(struct file * filp,
                                      unsigned int iocmd, unsigned long ioarg);
 
-static struct file_operations vnetFileOps;
+static struct file_operations vnetFileOps = {
+   .owner = THIS_MODULE,
+   .read = VNetFileOpRead,
+   .write = VNetFileOpWrite,
+   .poll = VNetFileOpPoll,
+   .unlocked_ioctl = VNetFileOpUnlockedIoctl,
+   .compat_ioctl = VNetFileOpUnlockedIoctl,
+   .open = VNetFileOpOpen,
+   .release = VNetFileOpClose
+};
 
 /*
  * Utility functions
@@ -317,22 +326,6 @@ init_module(void)
       goto err_proto;
    }
 
-   /*
-    * Initialize the file_operations structure. Because this code is always
-    * compiled as a module, this is fine to do it here and not in a static
-    * initializer.
-    */
-
-   memset(&vnetFileOps, 0, sizeof vnetFileOps);
-   vnetFileOps.owner = THIS_MODULE;
-   vnetFileOps.read = VNetFileOpRead;
-   vnetFileOps.write = VNetFileOpWrite;
-   vnetFileOps.poll = VNetFileOpPoll;
-   vnetFileOps.unlocked_ioctl = VNetFileOpUnlockedIoctl;
-   vnetFileOps.compat_ioctl = VNetFileOpUnlockedIoctl;
-   vnetFileOps.open = VNetFileOpOpen;
-   vnetFileOps.release = VNetFileOpClose;
-
    retval = register_chrdev(VNET_MAJOR_NUMBER, "vmnet", &vnetFileOps);
    if (retval) {
       LOG(0, (KERN_NOTICE "/dev/vmnet: could not register major device %d\n",
diff --git a/vmnet-only/vm_device_version.h b/vmnet-only/vm_device_version.h
index e2cb477..570b561 100644
--- a/vmnet-only/vm_device_version.h
+++ b/vmnet-only/vm_device_version.h
@@ -35,6 +35,8 @@
 #endif
 #endif
 
+#include <linux/pci_ids.h>
+
 /* LSILogic 53C1030 Parallel SCSI controller
  * LSILogic SAS1068 SAS controller
  */
@@ -53,7 +55,10 @@
  *    VMware HD Audio codec
  *    VMware HD Audio controller
  */
+#ifndef PCI_VENDOR_ID_VMWARE
 #define PCI_VENDOR_ID_VMWARE                    0x15AD
+#endif
+
 #define PCI_DEVICE_ID_VMWARE_SVGA2              0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA               0x0710
 #define PCI_DEVICE_ID_VMWARE_VGA                0x0711
@@ -70,7 +75,11 @@
 #define PCI_DEVICE_ID_VMWARE_1394               0x0780
 #define PCI_DEVICE_ID_VMWARE_BRIDGE             0x0790
 #define PCI_DEVICE_ID_VMWARE_ROOTPORT           0x07A0
+
+#ifndef PCI_DEVICE_ID_VMWARE_VMXNET3
 #define PCI_DEVICE_ID_VMWARE_VMXNET3            0x07B0
+#endif
+
 #define PCI_DEVICE_ID_VMWARE_PVSCSI             0x07C0
 #define PCI_DEVICE_ID_VMWARE_82574              0x07D0
 #define PCI_DEVICE_ID_VMWARE_AHCI               0x07E0
diff --git a/vmnet-only/vmnetInt.h b/vmnet-only/vmnetInt.h
index 8b376d5..afe1a5b 100644
--- a/vmnet-only/vmnetInt.h
+++ b/vmnet-only/vmnetInt.h
@@ -82,7 +82,7 @@ extern struct proto vmnet_proto;
                                                 PF_NETLINK, _pri, &vmnet_proto, 1)
 #elif defined(VMW_NETDEV_HAS_NET)
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(&init_net, \
-                                                PF_NETLINK, _pri, &vmnet_proto)
+                                                PF_NETLINK, _pri, &vmnet_proto, 0)
 #else
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(PF_NETLINK, _pri, &vmnet_proto, 1)
 #endif
diff --git a/vsock-only/Makefile b/vsock-only/Makefile
index 5d92e9b..139e972 100644
--- a/vsock-only/Makefile
+++ b/vsock-only/Makefile
@@ -49,10 +49,10 @@ VM_UNAME = $(shell uname -r)
 ifdef LINUXINCLUDE
 HEADER_DIR = $(LINUXINCLUDE)
 else
-HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
+HEADER_DIR = $(KERNEL_DIR)
 endif
 
-BUILD_DIR = $(HEADER_DIR)/..
+BUILD_DIR = $(KBUILD_OUTPUT)
 
 DRIVER := vsock
 PRODUCT := ws
diff --git a/vsock-only/linux/af_vsock.c b/vsock-only/linux/af_vsock.c
index bde1497..031c783 100644
--- a/vsock-only/linux/af_vsock.c
+++ b/vsock-only/linux/af_vsock.c
@@ -106,6 +106,7 @@
 #include <linux/list.h>
 #include <linux/wait.h>
 #include <linux/init.h>
+#include <linux/sched/signal.h>
 #include <asm/io.h>
 #if defined(__x86_64__) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
 #   include <linux/ioctl32.h>
@@ -212,7 +213,7 @@ static int VSockVmciDgramConnect(struct socket *sock,
                                  struct sockaddr *addr, int addrLen, int flags);
 static int VSockVmciStreamConnect(struct socket *sock,
                                   struct sockaddr *addr, int addrLen, int flags);
-static int VSockVmciAccept(struct socket *sock, struct socket *newsock, int flags);
+static int VSockVmciAccept(struct socket *sock, struct socket *newsock, int flags, bool kern);
 static int VSockVmciGetname(struct socket *sock,
                             struct sockaddr *addr, int *addrLen, int peer);
 static unsigned int VSockVmciPoll(struct file *file,
@@ -232,14 +233,10 @@ static int VSockVmciStreamSetsockopt(struct socket *sock, int level, int optname
 static int VSockVmciStreamGetsockopt(struct socket *sock, int level, int optname,
                                      char __user *optval, int __user * optlen);
 
-static int VSockVmciDgramSendmsg(struct kiocb *kiocb,
-                                 struct socket *sock, struct msghdr *msg, size_t len);
-static int VSockVmciDgramRecvmsg(struct kiocb *kiocb, struct socket *sock,
-                                 struct msghdr *msg, size_t len, int flags);
-static int VSockVmciStreamSendmsg(struct kiocb *kiocb,
-                                 struct socket *sock, struct msghdr *msg, size_t len);
-static int VSockVmciStreamRecvmsg(struct kiocb *kiocb, struct socket *sock,
-                                 struct msghdr *msg, size_t len, int flags);
+static int VSockVmciDgramSendmsg(struct socket *sock, struct msghdr *msg, size_t len);
+static int VSockVmciDgramRecvmsg(struct socket *sock, struct msghdr *msg, size_t len, int flags);
+static int VSockVmciStreamSendmsg(struct socket *sock, struct msghdr *msg, size_t len);
+static int VSockVmciStreamRecvmsg(struct socket *sock, struct msghdr *msg, size_t len, int flags);
 
 static int VSockVmciCreate(
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
@@ -2832,7 +2829,7 @@ __VSockVmciCreate(struct net *net,       // IN: Network namespace
 #elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
    sk = sk_alloc(vsockVmciFamilyOps.family, priority, &vsockVmciProto, 1);
 #else
-   sk = sk_alloc(net, vsockVmciFamilyOps.family, priority, &vsockVmciProto);
+   sk = sk_alloc(net, vsockVmciFamilyOps.family, priority, &vsockVmciProto, 0);
 #endif
    if (!sk) {
       return NULL;
@@ -3775,7 +3772,8 @@ outWaitError:
 static int
 VSockVmciAccept(struct socket *sock,     // IN
                 struct socket *newsock,  // IN/OUT
-                int flags)               // IN
+                int flags,               // IN
+                bool kern)               // IN
 {
    struct sock *listener;
    int err;
@@ -4210,8 +4208,7 @@ VSockVmciShutdown(struct socket *sock,  // IN
  */
 
 static int
-VSockVmciDgramSendmsg(struct kiocb *kiocb,          // UNUSED
-                      struct socket *sock,          // IN: socket to send on
+VSockVmciDgramSendmsg(struct socket *sock,          // IN: socket to send on
                       struct msghdr *msg,           // IN: message to send
                       size_t len)                   // IN: length of message
 {
@@ -4302,7 +4299,7 @@ VSockVmciDgramSendmsg(struct kiocb *kiocb,          // UNUSED
       goto out;
    }
 
-   memcpy_fromiovec(VMCI_DG_PAYLOAD(dg), msg->msg_iov, len);
+   memcpy_from_msg(VMCI_DG_PAYLOAD(dg), msg, len);
 
    dg->dst = VMCI_MAKE_HANDLE(remoteAddr->svm_cid, remoteAddr->svm_port);
    dg->src = VMCI_MAKE_HANDLE(vsk->localAddr.svm_cid, vsk->localAddr.svm_port);
@@ -4540,8 +4537,7 @@ VSockVmciStreamGetsockopt(struct socket *sock,          // IN
  */
 
 static int
-VSockVmciStreamSendmsg(struct kiocb *kiocb,          // UNUSED
-                       struct socket *sock,          // IN: socket to send on
+VSockVmciStreamSendmsg(struct socket *sock,          // IN: socket to send on
                        struct msghdr *msg,           // IN: message to send
                        size_t len)                   // IN: length of message
 {
@@ -4662,7 +4658,7 @@ VSockVmciStreamSendmsg(struct kiocb *kiocb,          // UNUSED
        * able to send.
        */
 
-      written = vmci_qpair_enquev(vsk->qpair, msg->msg_iov,
+      written = vmci_qpair_enquev(vsk->qpair, &msg->msg_iter.iov,
                                   len - totalWritten, 0);
       if (written < 0) {
          err = -ENOMEM;
@@ -4709,8 +4705,7 @@ out:
  */
 
 static int
-VSockVmciDgramRecvmsg(struct kiocb *kiocb,          // UNUSED
-                      struct socket *sock,          // IN: socket to receive from
+VSockVmciDgramRecvmsg(struct socket *sock,          // IN: socket to receive from
                       struct msghdr *msg,           // IN/OUT: message to receive into
                       size_t len,                   // IN: length of receive buffer
                       int flags)                    // IN: receive flags
@@ -4759,7 +4754,11 @@ VSockVmciDgramRecvmsg(struct kiocb *kiocb,          // UNUSED
    }
 
    /* Place the datagram payload in the user's iovec. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
    err = skb_copy_datagram_iovec(skb, sizeof *dg, msg->msg_iov, payloadLen);
+#else
+   err = skb_copy_datagram_iter(skb, sizeof *dg, &msg->msg_iter, payloadLen);
+#endif
    if (err) {
       goto out;
    }
@@ -4800,8 +4799,7 @@ out:
  */
 
 static int
-VSockVmciStreamRecvmsg(struct kiocb *kiocb,          // UNUSED
-                       struct socket *sock,          // IN: socket to receive from
+VSockVmciStreamRecvmsg(struct socket *sock,          // IN: socket to receive from
                        struct msghdr *msg,           // IN/OUT: message to receive into
                        size_t len,                   // IN: length of receive buffer
                        int flags)                    // IN: receive flags
@@ -4905,9 +4903,9 @@ VSockVmciStreamRecvmsg(struct kiocb *kiocb,          // UNUSED
          }
 
          if (flags & MSG_PEEK) {
-            read = vmci_qpair_peekv(vsk->qpair, msg->msg_iov, len - copied, 0);
+            read = vmci_qpair_peekv(vsk->qpair, &msg->msg_iter.iov, len - copied, 0);
          } else {
-            read = vmci_qpair_dequev(vsk->qpair, msg->msg_iov, len - copied, 0);
+            read = vmci_qpair_dequev(vsk->qpair, &msg->msg_iter.iov, len - copied, 0);
          }
 
          if (read < 0) {
diff --git a/vsock-only/linux/notify.c b/vsock-only/linux/notify.c
index 5b1e134..e902331 100644
--- a/vsock-only/linux/notify.c
+++ b/vsock-only/linux/notify.c
@@ -515,8 +515,11 @@ VSockVmciHandleWrote(struct sock *sk,            // IN
    vsk = vsock_sk(sk);
    PKT_FIELD(vsk, sentWaitingRead) = FALSE;
 #endif
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+   sk->sk_data_ready(sk);
+#else
    sk->sk_data_ready(sk, 0);
+#endif
 }
 
 
diff --git a/vsock-only/linux/notifyQState.c b/vsock-only/linux/notifyQState.c
index 464454b..743c39c 100644
--- a/vsock-only/linux/notifyQState.c
+++ b/vsock-only/linux/notifyQState.c
@@ -164,7 +164,11 @@ VSockVmciHandleWrote(struct sock *sk,            // IN
                      struct sockaddr_vm *dst,    // IN: unused
                      struct sockaddr_vm *src)    // IN: unused
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+   sk->sk_data_ready(sk);
+#else
    sk->sk_data_ready(sk, 0);
+#endif
 }
 
 
@@ -566,7 +570,11 @@ VSockVmciNotifyPktRecvPostDequeue(struct sock *sk,               // IN
       }
 
       /* See the comment in VSockVmciNotifyPktSendPostEnqueue */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+      sk->sk_data_ready(sk);
+#else
       sk->sk_data_ready(sk, 0);
+#endif
    }
 
    return err;
diff --git a/vsock-only/shared/compat_uaccess.h b/vsock-only/shared/compat_uaccess.h
index d58ee05..641bd2b 100644
--- a/vsock-only/shared/compat_uaccess.h
+++ b/vsock-only/shared/compat_uaccess.h
@@ -21,7 +21,9 @@
 
 
 /* User space access functions moved in 2.1.7 to asm/uaccess.h --hpreg */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 1, 7)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#   include <linux/uaccess.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 1, 7)
 #   include <asm/uaccess.h>
 #else
 #   include <asm/segment.h>
diff --git a/vsock-only/shared/vm_basic_defs.h b/vsock-only/shared/vm_basic_defs.h
index efe492a..1db0301 100644
--- a/vsock-only/shared/vm_basic_defs.h
+++ b/vsock-only/shared/vm_basic_defs.h
@@ -720,6 +720,7 @@ typedef int pid_t;
                                                      lfMessageFont)
 
 /* This is not intended to be thread-safe. */
+#ifndef DO_ONCE
 #define DO_ONCE(code)                                                   \
    do {                                                                 \
       static Bool _doOnceDone = FALSE;                                  \
@@ -728,6 +729,7 @@ typedef int pid_t;
          code;                                                          \
       }                                                                 \
    } while (0)
+#endif
 
 /*
  * Bug 827422 and 838523.
