diff --git a/Makefile b/Makefile
index e613d51..1a25855 100644
--- a/Makefile
+++ b/Makefile
@@ -612,6 +612,7 @@ SRCS_MPLAYER-$(TDFXVID)       += libvo/vo_tdfx_vid.c
 SRCS_MPLAYER-$(TGA)           += libvo/vo_tga.c
 SRCS_MPLAYER-$(V4L2)          += libvo/vo_v4l2.c
 SRCS_MPLAYER-$(V4L2)          += libao2/ao_v4l2.c
+SRCS_MPLAYER-$(VAAPI)         += libvo/vo_vaapi.c
 SRCS_MPLAYER-$(VDPAU)         += libvo/vo_vdpau.c
 SRCS_MPLAYER-$(VESA)          += libvo/gtf.c libvo/vo_vesa.c libvo/vesa_lvo.c
 SRCS_MPLAYER-$(VIDIX)         += libvo/vo_cvidix.c \
@@ -665,6 +666,7 @@ SRCS_MPLAYER = command.c \
                libvo/aspect.c \
                libvo/geometry.c \
                libvo/spuenc.c \
+               libvo/stats.c \
                libvo/video_out.c \
                libvo/vo_mpegpes.c \
                libvo/vo_null.c \
diff --git a/cfg-common-opts.h b/cfg-common-opts.h
index ff15f2c..bb082fa 100644
--- a/cfg-common-opts.h
+++ b/cfg-common-opts.h
@@ -228,6 +228,7 @@
 //	{"ac", &audio_codec, CONF_TYPE_STRING, 0, 0, 0, NULL},
 	{"ac", &audio_codec_list, CONF_TYPE_STRING_LIST, 0, 0, 0, NULL},
 	{"vc", &video_codec_list, CONF_TYPE_STRING_LIST, 0, 0, 0, NULL},
+	{"va", &video_hwaccel_name, CONF_TYPE_STRING, 0, 0, 0, NULL},
 
 	// postprocessing:
 #ifdef CONFIG_LIBAVCODEC
diff --git a/codec-cfg.c b/codec-cfg.c
index 86424b5..131dd00 100644
--- a/codec-cfg.c
+++ b/codec-cfg.c
@@ -187,6 +187,13 @@ static int add_to_format(char *s, char *alias,unsigned int *fourcc, unsigned int
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
+                {"VAAPI_MPEG2", IMGFMT_VAAPI_MPEG2},
+                {"VAAPI_MPEG4", IMGFMT_VAAPI_MPEG4},
+                {"VAAPI_H263",  IMGFMT_VAAPI_H263},
+                {"VAAPI_H264",  IMGFMT_VAAPI_H264},
+                {"VAAPI_WMV3",  IMGFMT_VAAPI_WMV3},
+                {"VAAPI_VC1",   IMGFMT_VAAPI_VC1},
+
 		{"VDPAU_MPEG1",IMGFMT_VDPAU_MPEG1},
 		{"VDPAU_MPEG2",IMGFMT_VDPAU_MPEG2},
 		{"VDPAU_H264",IMGFMT_VDPAU_H264},
diff --git a/configure b/configure
index 9c85f61..fbfc958 100755
--- a/configure
+++ b/configure
@@ -354,6 +354,9 @@ Codecs:
   --disable-muxer=MUXER     disable specified FFmpeg muxer
   --enable-muxer=MUXER      enable specified FFmpeg muxer
 
+Hardware acceleration:
+  --enable-vaapi            enable VA API acceleration [disable]
+
 Video output:
   --disable-vidix          disable VIDIX [for x86 *nix]
   --with-vidix-drivers[=*] list of VIDIX drivers to be compiled in
@@ -539,6 +542,8 @@ _libavutil_so=auto
 _libavcodec_a=auto
 _libopencore_amrnb=auto
 _libopencore_amrwb=auto
+_libavhwaccels_all=$(sed -n 's/^[^#]*HWACCEL.*(.*, *\(.*\)).*/\1_hwaccel/p' libavcodec/allcodecs.c | tr '[a-z]' '[A-Z]')
+_libavhwaccels="$_libavhwaccels_all"
 _libavdecoders_all=$(sed -n 's/^[^#]*DEC.*(.*, *\(.*\)).*/\1_decoder/p' libavcodec/allcodecs.c | tr '[a-z]' '[A-Z]')
 _libavdecoders=$(echo $_libavdecoders_all | sed -e 's/ LIB[A-Z0-9_]*_DECODER//g' -e s/MPEG4AAC_DECODER//)
 _libavencoders_all=$(sed -n 's/^[^#]*ENC.*(.*, *\(.*\)).*/\1_encoder/p' libavcodec/allcodecs.c | tr '[a-z]' '[A-Z]')
@@ -562,6 +567,9 @@ _libswscale_so=auto
 _libavcodec_mpegaudio_hp=yes
 _mencoder=yes
 _mplayer=yes
+_vaapi=auto
+_vaapi_glx=no
+_libgtop=auto
 _x11=auto
 _xshape=auto
 _xss=auto
@@ -904,6 +912,8 @@ for ac_option do
   --disable-mplayer)	_mplayer=no	;;
   --enable-dynamic-plugins) _dynamic_plugins=yes ;;
   --disable-dynamic-plugins) _dynamic_plugins=no ;;
+  --enable-vaapi)       _vaapi=yes      ;;
+  --disable-vaapi)      _vaapi=no       ;;
   --enable-x11)		_x11=yes	;;
   --disable-x11)	_x11=no		;;
   --enable-xshape)	_xshape=yes	;;
@@ -3794,6 +3804,28 @@ fi
 echores "$_gettimeofday"
 
 
+echocheck "clock_gettime()"
+cat > $TMPC << EOF
+#include <time.h>
+int main(void) {
+    struct timespec t;
+    clock_gettime(CLOCK_REALTIME, &t);
+    return 0;
+}
+EOF
+_clock_gettime=no
+cc_check -lrt && _clock_gettime=yes
+if test "$_clock_gettime" = yes ; then
+  def_clock_gettime='#define HAVE_CLOCK_GETTIME 1'
+  extra_ldflags="$extra_ldflags -lrt"
+  _need_clock_gettime=no
+else
+  def_clock_gettime='#undef HAVE_CLOCK_GETTIME'
+  _need_clock_gettime=yes
+fi
+echores "$_clock_gettime"
+
+
 echocheck "glob()"
 cat > $TMPC << EOF
 #include <stdio.h>
@@ -4222,7 +4254,7 @@ else
   _novomodules="x11 $_novomodules"
   _res_comment="check if the dev(el) packages are installed"
   # disable stuff that depends on X
-  _xv=no ; _xvmc=no ; _xinerama=no ; _vm=no ; _xf86keysym=no ; _vdpau=no
+  _xv=no ; _xvmc=no ; _xinerama=no ; _vm=no ; _xf86keysym=no ; _vaapi=no ; _vdpau=no
 fi
 echores "$_x11"
 
@@ -4350,7 +4382,7 @@ if test "$_vdpau" = yes ; then
 else
   def_vdpau='#define CONFIG_VDPAU 0'
   _novomodules="vdpau $_novomodules"
-  _libavdecoders=$(echo $_libavdecoders | sed -e s/MPEG_VDPAU_DECODER// -e s/MPEG1_VDPAU_DECODER// -e s/H264_VDPAU_DECODER// -e s/WMV3_VDPAU_DECODER// -e s/VC1_VDPAU_DECODER//)
+  _libavdecoders=$(echo $_libavdecoders | sed -e "s/\(MPEG\|MPEG[124]\|H26[34]\|WMV3\|VC1\)_VDPAU_DECODER//g")
 fi
 echores "$_vdpau"
 
@@ -4930,6 +4962,90 @@ else
 fi
 echores "$_gl"
 
+echocheck "OpenGL utilities (GLU)"
+_glu=no
+if test "$_gl" = yes; then
+  cat > $TMPC << EOF
+#include <GL/glu.h>
+int main(void) {
+  gluPerspective(0.0, 0.0, 0.0, 0.0);
+  return 0;
+}
+EOF
+  cc_check -lGLU && _glu=yes
+fi
+if test "$_glu" = yes; then
+  libs_mplayer="$libs_mplayer -lGLU"
+fi
+echores "$_glu"
+
+
+echocheck "VA API"
+if test "$_vaapi" = yes -o "$_vaapi" = auto; then
+  _vaapi=no
+  cat > $TMPC <<EOF
+#include <va/va_x11.h>
+int main(void) { (void) vaGetDisplay(0); return 0; }
+EOF
+  cc_check -lva-x11 && _vaapi=yes
+fi
+
+if test "$_vaapi" = yes ; then
+  def_vaapi='#define CONFIG_VAAPI 1'
+  libs_mencoder="$libs_mencoder -lva"
+  libs_mplayer="$libs_mplayer -lva-x11"
+  _vomodules="vaapi $_vomodules"
+else
+  def_vaapi='#define CONFIG_VAAPI 0'
+  _novomodules="vaapi $_novomodules"
+  _libavhwaccels=`echo $_libavhwaccels | sed -e "s/\(MPEG[124]\|H26[34]\|WMV3\|VC1\)_VAAPI_HWACCEL//g"`
+fi
+echores "$_vaapi"
+
+echocheck "VA API (with GLX support)"
+if test "$_vaapi" = yes; then
+  _vaapi_glx=no
+  if test "$_gl" = "yes" -a "$_glu" = yes; then
+    cat > $TMPC <<EOF
+#include <va/va_glx.h>
+int main(void) { (void) vaGetDisplayGLX(0); return 0; }
+EOF
+    cc_check -lva-glx && _vaapi_glx=yes
+  fi
+fi
+if test "$_vaapi_glx" = yes; then
+  def_vaapi_glx='#define CONFIG_VAAPI_GLX 1'
+  libs_mplayer="$libs_mplayer -lva-glx"
+else
+  def_vaapi_glx='#define CONFIG_VAAPI_GLX 0'
+fi
+echores "$_vaapi_glx"
+
+
+echocheck "libgtop"
+if test "$_libgtop" = auto ; then
+  _libgtop=no
+  if $_pkg_config --exists 'libgtop-2.0' ; then
+
+cat > $TMPC << EOF
+#include <glibtop/cpu.h>
+#include <glibtop/proctime.h>
+int main(void) { return 0; }
+EOF
+cc_check $($_pkg_config --libs --cflags libgtop-2.0) && tmp_run && _libgtop=yes
+
+  fi
+fi
+echores "$_libgtop"
+
+if test "$_libgtop" = yes ; then
+  def_libgtop='#define CONFIG_LIBGTOP 1'
+  libs_mplayer="$libs_mplayer $($_pkg_config --libs libgtop-2.0)"
+  extra_cflags="$extra_cflags $($_pkg_config --cflags libgtop-2.0)"
+else
+  def_libgtop='#define CONFIG_LIBGTOP 0'
+fi
+
 
 echocheck "PNG support"
 if test "$_png" = auto ; then
@@ -8359,6 +8475,7 @@ TV_V4L2 = $_tv_v4l2
 TWOLAME=$_twolame
 UNRAR_EXEC = $_unrar_exec
 V4L2 = $_v4l2
+VAAPI = $_vaapi
 VCD = $_vcd
 VDPAU = $_vdpau
 VESA = $_vesa
@@ -8439,6 +8556,7 @@ CONFIG_GPL=yes
 CONFIG_LIBDIRAC_DECODER=$_libdirac_lavc
 CONFIG_LIBDIRAC_ENCODER=$_libdirac_lavc
 CONFIG_LIBFAAC_ENCODER=$_faac_lavc
+CONFIG_LIBGTOP=$_libgtop
 CONFIG_LIBMP3LAME_ENCODER=$_mp3lame_lavc
 CONFIG_LIBOPENCORE_AMRNB_DECODER=$_libopencore_amrnb
 CONFIG_LIBOPENCORE_AMRNB_ENCODER=$_libopencore_amrnb
@@ -8453,6 +8571,7 @@ CONFIG_MUXERS=$_mencoder
 CONFIG_POSTPROC = yes
 # Prevent building libavcodec/imgresample.c with conflicting symbols
 CONFIG_SWSCALE=yes
+CONFIG_VAAPI=$_vaapi
 CONFIG_VDPAU=$_vdpau
 CONFIG_XVMC=$_xvmc
 CONFIG_ZLIB=$_zlib
@@ -8462,6 +8581,7 @@ HAVE_SHM = $_shm
 HAVE_W32THREADS = $_w32threads
 HAVE_YASM = $_have_yasm
 
+$(echo $_libavhwaccels | tr '[a-z] ' '[A-Z]\n' | sed 's/^/CONFIG_/;s/$/=yes/')
 $(echo $_libavdecoders | tr '[a-z] ' '[A-Z]\n' | sed 's/^/CONFIG_/;s/$/=yes/')
 $(echo $_libavencoders | tr '[a-z] ' '[A-Z]\n' | sed 's/^/CONFIG_/;s/$/=yes/')
 $(echo $_libavparsers | tr '[a-z] ' '[A-Z]\n' | sed 's/^/CONFIG_/;s/$/=yes/')
@@ -8567,6 +8687,7 @@ $def_winsock2_h
 
 
 /* system functions */
+$def_clock_gettime
 $def_gethostbyname2
 $def_gettimeofday
 $def_glob
@@ -8602,6 +8723,7 @@ $def_extern_asm
 $def_extern_prefix
 $def_iconv
 $def_kstat
+$def_libgtop
 $def_macosx_bundle
 $def_macosx_finder
 $def_maemo
@@ -8822,6 +8944,8 @@ $def_tdfxfb
 $def_tdfxvid
 $def_tga
 $def_v4l2
+$def_vaapi
+$def_vaapi_glx
 $def_vdpau
 $def_vesa
 $def_vidix
@@ -8939,6 +9063,7 @@ $def_mp3lame_lavc
 $def_x264_lavc
 $def_xvid_lavc
 
+$(ff_config_enable "$_libavhwaccels_all" "$_libavhwaccels")
 $(ff_config_enable "$_libavdecoders_all" "$_libavdecoders")
 $(ff_config_enable "$_libavencoders_all" "$_libavencoders")
 $(ff_config_enable "$_libavparsers_all"  "$_libavparsers")
@@ -8947,13 +9072,6 @@ $(ff_config_enable "$_libavmuxers_all"   "$_libavmuxers")
 $(ff_config_enable "$_libavprotocols_all" "$_libavprotocols")
 $(ff_config_enable "$_libavbsfs_all" "$_libavbsfs")
 
-#define CONFIG_H263_VAAPI_HWACCEL 0
-#define CONFIG_MPEG2_VAAPI_HWACCEL 0
-#define CONFIG_MPEG4_VAAPI_HWACCEL 0
-#define CONFIG_H264_VAAPI_HWACCEL 0
-#define CONFIG_VC1_VAAPI_HWACCEL 0
-#define CONFIG_WMV3_VAAPI_HWACCEL 0
-
 #endif /* MPLAYER_CONFIG_H */
 EOF
 
diff --git a/etc/codecs.conf b/etc/codecs.conf
index bdf3568..6b5c0b5 100644
--- a/etc/codecs.conf
+++ b/etc/codecs.conf
@@ -164,6 +164,7 @@ videocodec ffmpeg2
   fourcc LMP2 ; Lead mpeg2 in avi
   driver ffmpeg
   dll "mpeg2video"
+  out VAAPI_MPEG2
   out YV12,I420,IYUV
   out 422P,444P
 
@@ -847,6 +848,7 @@ videocodec ffwmv3
   fourcc WMV3,wmv3
   driver ffmpeg
   dll wmv3
+  out VAAPI_WMV3
   out YV12,I420,IYUV
 
 videocodec ffwmv3vdpau
@@ -864,6 +866,7 @@ videocodec ffvc1
   fourcc vc-1,VC-1
   driver ffmpeg
   dll vc1
+  out VAAPI_VC1
   out YV12,I420,IYUV
 
 videocodec ffvc1vdpau
@@ -885,6 +888,7 @@ videocodec ffh264
   format 0x10000005
   driver ffmpeg
   dll h264
+  out VAAPI_H264
   out YV12,I420,IYUV
 
 videocodec ffh264vdpau
@@ -952,6 +956,7 @@ videocodec ffodivx
   fourcc EPHV,SN40
   driver ffmpeg
   dll mpeg4 ;opendivx
+  out VAAPI_MPEG4
   out YV12,I420,IYUV
 
 videocodec ffwv1f
@@ -1471,6 +1476,7 @@ videocodec ffh263
   fourcc VX1K     ; Agora Labs VX1000S H263
   driver ffmpeg
   dll h263
+  out VAAPI_H263
   out YV12,I420,IYUV
 
 videocodec ffzygo
diff --git a/fmt-conversion.c b/fmt-conversion.c
index 05179d1..517db68 100644
--- a/fmt-conversion.c
+++ b/fmt-conversion.c
@@ -18,12 +18,14 @@
 
 #include "mp_msg.h"
 #include "libavutil/avutil.h"
+#include "libavcodec/avcodec.h"
 #include "libmpcodecs/img_format.h"
 #include "fmt-conversion.h"
 
 static const struct {
     int fmt;
     enum PixelFormat pix_fmt;
+    enum CodecID codec_id;
 } conversion_map[] = {
     {IMGFMT_BGR32, PIX_FMT_RGB32},
     {IMGFMT_BGR24, PIX_FMT_BGR24},
@@ -73,6 +75,17 @@ static const struct {
     {IMGFMT_VDPAU_H264,      PIX_FMT_VDPAU_H264},
     {IMGFMT_VDPAU_WMV3,      PIX_FMT_VDPAU_WMV3},
     {IMGFMT_VDPAU_VC1,       PIX_FMT_VDPAU_VC1},
+
+    /* VA API formats */
+    {IMGFMT_VAAPI_MPEG2,     PIX_FMT_VAAPI_VLD,  CODEC_ID_MPEG2VIDEO},
+    {IMGFMT_VAAPI_MPEG2_IDCT,PIX_FMT_VAAPI_IDCT, CODEC_ID_MPEG2VIDEO},
+    {IMGFMT_VAAPI_MPEG2_MOCO,PIX_FMT_VAAPI_MOCO, CODEC_ID_MPEG2VIDEO},
+    {IMGFMT_VAAPI_MPEG4,     PIX_FMT_VAAPI_VLD,  CODEC_ID_MPEG4},
+    {IMGFMT_VAAPI_H263,      PIX_FMT_VAAPI_VLD,  CODEC_ID_H263},
+    {IMGFMT_VAAPI_H264,      PIX_FMT_VAAPI_VLD,  CODEC_ID_H264},
+    {IMGFMT_VAAPI_WMV3,      PIX_FMT_VAAPI_VLD,  CODEC_ID_WMV3},
+    {IMGFMT_VAAPI_VC1,       PIX_FMT_VAAPI_VLD,  CODEC_ID_VC1},
+
     {0, PIX_FMT_NONE}
 };
 
@@ -89,12 +102,14 @@ enum PixelFormat imgfmt2pixfmt(int fmt)
     return pix_fmt;
 }
 
-int pixfmt2imgfmt(enum PixelFormat pix_fmt)
+int pixfmt2imgfmt(enum PixelFormat pix_fmt, int codec_id)
 {
     int i;
     int fmt;
     for (i = 0; conversion_map[i].pix_fmt != PIX_FMT_NONE; i++)
-        if (conversion_map[i].pix_fmt == pix_fmt)
+        if (conversion_map[i].pix_fmt == pix_fmt &&
+            (conversion_map[i].codec_id == 0 ||
+             conversion_map[i].codec_id == codec_id))
             break;
     fmt = conversion_map[i].fmt;
     if (!fmt)
diff --git a/fmt-conversion.h b/fmt-conversion.h
index f1e44ff..5eb5684 100644
--- a/fmt-conversion.h
+++ b/fmt-conversion.h
@@ -4,6 +4,6 @@
 #include "libavutil/avutil.h"
 
 enum PixelFormat imgfmt2pixfmt(int fmt);
-int pixfmt2imgfmt(enum PixelFormat pix_fmt);
+int pixfmt2imgfmt(enum PixelFormat pix_fmt, int codec_id);
 
 #endif /* MPLAYER_FMT_CONVERSION_H */
diff --git a/gui/mplayer/gtk/opts.c b/gui/mplayer/gtk/opts.c
index a1c8d22..06e1269 100644
--- a/gui/mplayer/gtk/opts.c
+++ b/gui/mplayer/gtk/opts.c
@@ -63,9 +63,11 @@ static GtkWidget * CLVDrivers;
        GtkWidget * prEFontName;
        GtkWidget * prEDVDDevice;
        GtkWidget * prECDRomDevice;
+static GtkWidget * EVHW;
 static GtkWidget * EVFM;
 static GtkWidget * EAFM;
 
+static GtkWidget * CBVHW;
 static GtkWidget * CBVFM;
 static GtkWidget * CBAFM;
 static GtkWidget * CBAudioEqualizer;
@@ -353,6 +355,26 @@ void ShowPreferences( void )
 // -- 5. page
  gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON( CBNonInterlaved ),force_ni );
  if ( index_mode == 1 ) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON( CBIndex ),1 );
+
+ {
+     int     i;
+     GList * Items = NULL;
+     char  * name  = NULL;
+
+     Items = g_list_append(Items, MSGTR_PREFERENCES_None);
+     for (i = 0; i < HWACCEL_COUNT; i++) {
+         const char *hwaccel_name = get_video_hwaccel_name(i);
+         if (!hwaccel_name)
+             continue;
+         Items = g_list_append(Items, hwaccel_name);
+         if (video_hwaccel_name && !gstrcmp(video_hwaccel_name, get_video_hwaccel_short_name(i) ) ) name = hwaccel_name;
+     }
+     gtk_combo_set_popdown_strings(GTK_COMBO(CBVHW), Items);
+     g_list_free(Items);
+     if (name)
+         gtk_entry_set_text(GTK_ENTRY(EVHW), name);
+ }
+
  {
   int     i;
   GList * Items = NULL;
@@ -599,6 +621,17 @@ void prButton( GtkButton * button,gpointer user_data )
 	if ( gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON( CBIndex ) ) ) index_mode=1;
 
 	{
+            int i;
+            const char *tmp = gtk_entry_get_text(GTK_ENTRY(EVHW));
+            for (i = 0; i < HWACCEL_COUNT; i++) {
+                if (!gstrcmp(tmp, get_video_hwaccel_name(i))) {
+                    video_hwaccel_name = get_video_hwaccel_short_name(i);
+                    break;
+                }
+            }
+        }
+
+	{
 	 int i;
 	 const char * tmp = gtk_entry_get_text( GTK_ENTRY( EVFM ) );
          for( i=0;mpcodecs_vd_drivers[i];i++ )
@@ -1198,6 +1231,20 @@ GtkWidget * create_Preferences( void )
 
   hbox5=AddHBox( vbox602,1 );
 
+  AddLabel( MSGTR_PREFERENCES_VideoHardwareAcceleration,hbox5 );
+
+  CBVHW=gtk_combo_new();
+  gtk_widget_set_name( CBVHW,"CBVHW" );
+  gtk_widget_show( CBVHW );
+  gtk_box_pack_start( GTK_BOX( hbox5 ),CBVHW,TRUE,TRUE,0 );
+
+  EVHW=GTK_COMBO( CBVHW )->entry;
+  gtk_widget_set_name( EVHW,"CEVHW" );
+  gtk_entry_set_editable( GTK_ENTRY( EVHW ),FALSE );
+  gtk_widget_show( EVHW );
+
+  hbox5=AddHBox( vbox602,1 );
+
   AddLabel( MSGTR_PREFERENCES_VideoCodecFamily,hbox5 );
 
   CBVFM=gtk_combo_new();
diff --git a/help/help_mp-en.h b/help/help_mp-en.h
index 03c4249..dfbf714 100644
--- a/help/help_mp-en.h
+++ b/help/help_mp-en.h
@@ -718,6 +718,7 @@ static const char help_text[]=
 #define MSGTR_PREFERENCES_IDX "Rebuild index table, if needed"
 #define MSGTR_PREFERENCES_VideoCodecFamily "Video codec family:"
 #define MSGTR_PREFERENCES_AudioCodecFamily "Audio codec family:"
+#define MSGTR_PREFERENCES_VideoHardwareAcceleration "Video hardware acceleration:"
 #define MSGTR_PREFERENCES_FRAME_OSD_Level "OSD level"
 #define MSGTR_PREFERENCES_FRAME_Subtitle "Subtitle"
 #define MSGTR_PREFERENCES_FRAME_Font "Font"
@@ -1657,6 +1658,7 @@ static const char help_text[]=
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
 #define MSGTR_MPCODECS_UnrecoverableErrorRenderBuffersNotTaken "[VD_FFMPEG] Unrecoverable error, render buffers not taken.\n"
 #define MSGTR_MPCODECS_OnlyBuffersAllocatedByVoXvmcAllowed "[VD_FFMPEG] Only buffers allocated by vo_xvmc allowed.\n"
+#define MSGTR_MPCODECS_VAAPIAcceleratedCodec "[VD_FFMPEG] VA API accelerated codec.\n"
 
 // libmpcodecs/ve_lavc.c
 #define MSGTR_MPCODECS_HighQualityEncodingSelected "[VE_LAVC] High quality encoding selected (non-realtime)!\n"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 21cba37..1a3c998 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -3,7 +3,7 @@ include $(SUBDIR)../config.mak
 NAME = avcodec
 FFLIBS = avutil
 
-HEADERS = avcodec.h opt.h vdpau.h xvmc.h
+HEADERS = avcodec.h opt.h vaapi.h vdpau.h xvmc.h
 
 OBJS = allcodecs.o                                                      \
        audioconvert.o                                                   \
@@ -137,6 +137,7 @@ OBJS-$(CONFIG_H264_DECODER)            += h264.o h264idct.o h264pred.o \
                                           h264_parser.o cabac.o        \
                                           mpegvideo.o error_resilience.o
 OBJS-$(CONFIG_H264_ENCODER)            += h264enc.o h264dspenc.o
+OBJS-$(CONFIG_H264_VAAPI_HWACCEL)      += vaapi_h264.o
 OBJS-$(CONFIG_HUFFYUV_DECODER)         += huffyuv.o
 OBJS-$(CONFIG_HUFFYUV_ENCODER)         += huffyuv.o
 OBJS-$(CONFIG_IDCIN_DECODER)           += idcinvideo.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 482cbd6..05efb41 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -55,6 +55,7 @@ void avcodec_register_all(void)
 
     /* hardware accelerators */
     REGISTER_HWACCEL (H263_VAAPI, h263_vaapi);
+    REGISTER_HWACCEL (H264_VAAPI, h264_vaapi);
     REGISTER_HWACCEL (MPEG2_VAAPI, mpeg2_vaapi);
     REGISTER_HWACCEL (MPEG4_VAAPI, mpeg4_vaapi);
     REGISTER_HWACCEL (VC1_VAAPI, vc1_vaapi);
diff --git a/libavcodec/vaapi_h264.c b/libavcodec/vaapi_h264.c
new file mode 100644
index 0000000..f1f5cbf
--- /dev/null
+++ b/libavcodec/vaapi_h264.c
@@ -0,0 +1,353 @@
+/*
+ * H.264 HW decode acceleration through VA API
+ *
+ * Copyright (C) 2008-2009 Splitted-Desktop Systems
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "vaapi_internal.h"
+#include "h264.h"
+
+/** @file
+ *  This file implements the glue code between FFmpeg's and VA API's
+ *  structures for H.264 decoding.
+ */
+
+/** Reconstruct bitstream slice_type. */
+static int get_slice_type(H264Context *h)
+{
+    switch (h->slice_type) {
+    case FF_P_TYPE:  return 0;
+    case FF_B_TYPE:  return 1;
+    case FF_I_TYPE:  return 2;
+    case FF_SP_TYPE: return 3;
+    case FF_SI_TYPE: return 4;
+    default:         return -1;
+    }
+}
+
+/**
+ * Initialize an empty VA API picture.
+ *
+ * VA API requires a fixed-size reference picture array.
+ */
+static void init_vaapi_pic(VAPictureH264 *va_pic)
+{
+    va_pic->picture_id          = 0xffffffff;
+    va_pic->flags               = VA_PICTURE_H264_INVALID;
+    va_pic->TopFieldOrderCnt    = 0;
+    va_pic->BottomFieldOrderCnt = 0;
+}
+
+/**
+ * Translate an FFmpeg Picture into its VA API form.
+ *
+ * @param[out] va_pic          A pointer to VA API's own picture struct
+ * @param[in]  pic             A pointer to the FFmpeg picture struct to convert
+ * @param[in]  pic_structure   The picture field type (as defined in mpegvideo.h),
+ *                             supersedes pic's field type if nonzero.
+ */
+static void fill_vaapi_pic(VAPictureH264 *va_pic,
+                           Picture       *pic,
+                           int            pic_structure)
+{
+    if (pic_structure == 0)
+        pic_structure = pic->reference;
+
+    va_pic->picture_id = ff_vaapi_get_surface(pic);
+    va_pic->frame_idx  = pic->long_ref ? pic->pic_id : pic->frame_num;
+
+    va_pic->flags      = 0;
+    if (pic_structure != PICT_FRAME)
+        va_pic->flags |= (pic_structure & PICT_TOP_FIELD) ? VA_PICTURE_H264_TOP_FIELD : VA_PICTURE_H264_BOTTOM_FIELD;
+    if (pic->reference)
+        va_pic->flags |= pic->long_ref ? VA_PICTURE_H264_LONG_TERM_REFERENCE : VA_PICTURE_H264_SHORT_TERM_REFERENCE;
+
+    va_pic->TopFieldOrderCnt = 0;
+    if ((pic_structure & PICT_TOP_FIELD) && pic->field_poc[0] != INT_MAX)
+        va_pic->TopFieldOrderCnt = pic->field_poc[0];
+
+    va_pic->BottomFieldOrderCnt = 0;
+    if ((pic_structure & PICT_BOTTOM_FIELD) && pic->field_poc[1] != INT_MAX)
+        va_pic->BottomFieldOrderCnt = pic->field_poc[1];
+}
+
+/** Decoded Picture Buffer (DPB). */
+typedef struct DPB {
+    unsigned int   size;
+    unsigned int   max_size;
+    VAPictureH264 *pics;
+} DPB;
+
+/**
+ * Append picture to the decoded picture buffer, in a VA API form that
+ * merges the second field picture attributes with the first, if
+ * available.  The decoded picture buffer's size must be large enough
+ * to receive the new VA API picture object.
+ */
+static int dpb_add(DPB *dpb, Picture *pic)
+{
+    unsigned int i;
+
+    if (dpb->size >= dpb->max_size)
+        return -1;
+
+    for (i = 0; i < dpb->size; i++) {
+        VAPictureH264 * const va_pic = &dpb->pics[i];
+        if (va_pic->picture_id == ff_vaapi_get_surface(pic)) {
+            VAPictureH264 temp_va_pic;
+            fill_vaapi_pic(&temp_va_pic, pic, 0);
+
+            if ((temp_va_pic.flags ^ va_pic->flags) & (VA_PICTURE_H264_TOP_FIELD | VA_PICTURE_H264_BOTTOM_FIELD)) {
+                va_pic->flags |= temp_va_pic.flags & (VA_PICTURE_H264_TOP_FIELD | VA_PICTURE_H264_BOTTOM_FIELD);
+                /* Merge second field */
+                if (temp_va_pic.flags & VA_PICTURE_H264_TOP_FIELD)
+                    va_pic->TopFieldOrderCnt    = temp_va_pic.TopFieldOrderCnt;
+                else
+                    va_pic->BottomFieldOrderCnt = temp_va_pic.BottomFieldOrderCnt;
+            }
+            return 0;
+        }
+    }
+
+    fill_vaapi_pic(&dpb->pics[dpb->size++], pic, 0);
+    return 0;
+}
+
+/** Fill in VA API reference frames array. */
+static int fill_vaapi_ReferenceFrames(VAPictureParameterBufferH264 *pic_param,
+                                      H264Context                  *h)
+{
+    DPB dpb;
+    unsigned int i, list;
+
+    dpb.size     = 0;
+    dpb.max_size = FF_ARRAY_ELEMS(pic_param->ReferenceFrames);
+    dpb.pics     = pic_param->ReferenceFrames;
+    for (i = 0; i < dpb.max_size; i++)
+        init_vaapi_pic(&dpb.pics[i]);
+
+    for (list = 0; list < h->list_count; list++)
+        for (i = 0; i < h->ref_count[list]; i++) {
+            Picture * const pic = &h->ref_list[list][i];
+            if (pic->reference && dpb_add(&dpb, pic) < 0)
+                return -1;
+        }
+    return 0;
+}
+
+/**
+ * Fill in VA API reference picture lists from the FFmpeg reference picture list.
+ *
+ * @param[out] RefPicList  VA API internal reference picture list
+ * @param[in]  ref_list    A pointer to the FFmpeg reference list
+ * @param[in]  ref_count   The number of reference pictures in ref_list
+ */
+static void fill_vaapi_RefPicList(VAPictureH264 RefPicList[32],
+                                  Picture      *ref_list,
+                                  unsigned int  ref_count)
+{
+    unsigned int i, n = 0;
+    for (i = 0; i < ref_count; i++)
+        if (ref_list[i].reference)
+            fill_vaapi_pic(&RefPicList[n++], &ref_list[i], 0);
+
+    for (; n < 32; n++)
+        init_vaapi_pic(&RefPicList[n]);
+}
+
+/**
+ * Fill in prediction weight table.
+ *
+ * VA API requires a plain prediction weight table as it does not infer
+ * any value.
+ *
+ * @param[in]  h                   A pointer to the current H.264 context
+ * @param[in]  list                The reference frame list index to use
+ * @param[out] luma_weight_flag    VA API plain luma weight flag
+ * @param[out] luma_weight         VA API plain luma weight table
+ * @param[out] luma_offset         VA API plain luma offset table
+ * @param[out] chroma_weight_flag  VA API plain chroma weight flag
+ * @param[out] chroma_weight       VA API plain chroma weight table
+ * @param[out] chroma_offset       VA API plain chroma offset table
+ */
+static void fill_vaapi_plain_pred_weight_table(H264Context   *h,
+                                               int            list,
+                                               unsigned char *luma_weight_flag,
+                                               short          luma_weight[32],
+                                               short          luma_offset[32],
+                                               unsigned char *chroma_weight_flag,
+                                               short          chroma_weight[32][2],
+                                               short          chroma_offset[32][2])
+{
+    unsigned int i, j;
+
+    *luma_weight_flag    = h->luma_weight_flag[list];
+    *chroma_weight_flag  = h->chroma_weight_flag[list];
+
+    for (i = 0; i < h->ref_count[list]; i++) {
+        /* VA API also wants the inferred (default) values, not
+           only what is available in the bitstream (7.4.3.2). */
+        if (h->luma_weight_flag[list]) {
+            luma_weight[i] = h->luma_weight[list][i];
+            luma_offset[i] = h->luma_offset[list][i];
+        } else {
+            luma_weight[i] = 1 << h->luma_log2_weight_denom;
+            luma_offset[i] = 0;
+        }
+        for (j = 0; j < 2; j++) {
+            if (h->chroma_weight_flag[list]) {
+                chroma_weight[i][j] = h->chroma_weight[list][i][j];
+                chroma_offset[i][j] = h->chroma_offset[list][i][j];
+            } else {
+                chroma_weight[i][j] = 1 << h->chroma_log2_weight_denom;
+                chroma_offset[i][j] = 0;
+            }
+        }
+    }
+}
+
+/** Initialize and start decoding a frame with VA API. */
+static int start_frame(AVCodecContext          *avctx,
+                       av_unused const uint8_t *buffer,
+                       av_unused uint32_t       size)
+{
+    H264Context * const h = avctx->priv_data;
+    MpegEncContext * const s = &h->s;
+    struct vaapi_context * const vactx = avctx->hwaccel_context;
+    VAPictureParameterBufferH264 *pic_param;
+    VAIQMatrixBufferH264 *iq_matrix;
+
+    dprintf(avctx, "start_frame()\n");
+
+    vactx->slice_param_size = sizeof(VASliceParameterBufferH264);
+
+    /* Fill in VAPictureParameterBufferH264. */
+    pic_param = ff_vaapi_alloc_picture(vactx, sizeof(VAPictureParameterBufferH264));
+    if (!pic_param)
+        return -1;
+    fill_vaapi_pic(&pic_param->CurrPic, s->current_picture_ptr, s->picture_structure);
+    if (fill_vaapi_ReferenceFrames(pic_param, h) < 0)
+        return -1;
+    pic_param->picture_width_in_mbs_minus1                      = s->mb_width - 1;
+    pic_param->picture_height_in_mbs_minus1                     = s->mb_height - 1;
+    pic_param->bit_depth_luma_minus8                            = h->sps.bit_depth_luma >= 8 ? h->sps.bit_depth_luma - 8 : 0;
+    pic_param->bit_depth_chroma_minus8                          = h->sps.bit_depth_chroma >= 8 ? h->sps.bit_depth_chroma - 8 : 0;
+    pic_param->num_ref_frames                                   = h->sps.ref_frame_count;
+    pic_param->seq_fields.value                                 = 0; /* reset all bits */
+    pic_param->seq_fields.bits.chroma_format_idc                = h->sps.chroma_format_idc;
+    pic_param->seq_fields.bits.residual_colour_transform_flag   = h->sps.residual_color_transform_flag; /* XXX: only for 4:4:4 high profile? */
+    pic_param->seq_fields.bits.gaps_in_frame_num_value_allowed_flag = h->sps.gaps_in_frame_num_allowed_flag;
+    pic_param->seq_fields.bits.frame_mbs_only_flag              = h->sps.frame_mbs_only_flag;
+    pic_param->seq_fields.bits.mb_adaptive_frame_field_flag     = h->sps.mb_aff;
+    pic_param->seq_fields.bits.direct_8x8_inference_flag        = h->sps.direct_8x8_inference_flag;
+    pic_param->seq_fields.bits.MinLumaBiPredSize8x8             = h->sps.level_idc >= 31; /* A.3.3.2 */
+    pic_param->seq_fields.bits.log2_max_frame_num_minus4        = h->sps.log2_max_frame_num - 4;
+    pic_param->seq_fields.bits.pic_order_cnt_type               = h->sps.poc_type;
+    pic_param->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4 = h->sps.log2_max_poc_lsb - 4;
+    pic_param->seq_fields.bits.delta_pic_order_always_zero_flag = h->sps.delta_pic_order_always_zero_flag;
+    pic_param->num_slice_groups_minus1                          = h->pps.slice_group_count - 1;
+    pic_param->slice_group_map_type                             = h->pps.mb_slice_group_map_type;
+    pic_param->slice_group_change_rate_minus1                   = 0; /* XXX: unimplemented in FFmpeg */
+    pic_param->pic_init_qp_minus26                              = h->pps.init_qp - 26;
+    pic_param->pic_init_qs_minus26                              = h->pps.init_qs - 26;
+    pic_param->chroma_qp_index_offset                           = h->pps.chroma_qp_index_offset[0];
+    pic_param->second_chroma_qp_index_offset                    = h->pps.chroma_qp_index_offset[1];
+    pic_param->pic_fields.value                                 = 0; /* reset all bits */
+    pic_param->pic_fields.bits.entropy_coding_mode_flag         = h->pps.cabac;
+    pic_param->pic_fields.bits.weighted_pred_flag               = h->pps.weighted_pred;
+    pic_param->pic_fields.bits.weighted_bipred_idc              = h->pps.weighted_bipred_idc;
+    pic_param->pic_fields.bits.transform_8x8_mode_flag          = h->pps.transform_8x8_mode;
+    pic_param->pic_fields.bits.field_pic_flag                   = h->s.picture_structure != PICT_FRAME;
+    pic_param->pic_fields.bits.constrained_intra_pred_flag      = h->pps.constrained_intra_pred;
+    pic_param->pic_fields.bits.pic_order_present_flag           = h->pps.pic_order_present;
+    pic_param->pic_fields.bits.deblocking_filter_control_present_flag = h->pps.deblocking_filter_parameters_present;
+    pic_param->pic_fields.bits.redundant_pic_cnt_present_flag   = h->pps.redundant_pic_cnt_present;
+    pic_param->pic_fields.bits.reference_pic_flag               = h->nal_ref_idc != 0;
+    pic_param->frame_num                                        = h->frame_num;
+
+    /* Fill in VAIQMatrixBufferH264. */
+    iq_matrix = ff_vaapi_alloc_iq_matrix(vactx, sizeof(VAIQMatrixBufferH264));
+    if (!iq_matrix)
+        return -1;
+    memcpy(iq_matrix->ScalingList4x4, h->pps.scaling_matrix4, sizeof(iq_matrix->ScalingList4x4));
+    memcpy(iq_matrix->ScalingList8x8, h->pps.scaling_matrix8, sizeof(iq_matrix->ScalingList8x8));
+    return 0;
+}
+
+/** End a hardware decoding based frame. */
+static int end_frame(AVCodecContext *avctx)
+{
+    H264Context * const h = avctx->priv_data;
+
+    dprintf(avctx, "end_frame()\n");
+    return ff_vaapi_common_end_frame(&h->s);
+}
+
+/** Decode the given H.264 slice with VA API. */
+static int decode_slice(AVCodecContext *avctx,
+                        const uint8_t  *buffer,
+                        uint32_t        size)
+{
+    H264Context * const h = avctx->priv_data;
+    MpegEncContext * const s = &h->s;
+    VASliceParameterBufferH264 *slice_param;
+
+    dprintf(avctx, "decode_slice(): buffer %p, size %d\n", buffer, size);
+
+    /* Fill in VASliceParameterBufferH264. */
+    slice_param = (VASliceParameterBufferH264 *)ff_vaapi_alloc_slice(avctx->hwaccel_context, buffer, size);
+    if (!slice_param)
+        return -1;
+    slice_param->slice_data_bit_offset          = get_bits_count(&h->s.gb) + 8; /* bit buffer started beyond nal_unit_type */
+    slice_param->first_mb_in_slice              = (s->mb_y >> FIELD_OR_MBAFF_PICTURE) * s->mb_width + s->mb_x;
+    slice_param->slice_type                     = get_slice_type(h);
+    slice_param->direct_spatial_mv_pred_flag    = h->slice_type == FF_B_TYPE ? h->direct_spatial_mv_pred : 0;
+    slice_param->num_ref_idx_l0_active_minus1   = h->list_count > 0 ? h->ref_count[0] - 1 : 0;
+    slice_param->num_ref_idx_l1_active_minus1   = h->list_count > 1 ? h->ref_count[1] - 1 : 0;
+    slice_param->cabac_init_idc                 = h->cabac_init_idc;
+    slice_param->slice_qp_delta                 = s->qscale - h->pps.init_qp;
+    slice_param->disable_deblocking_filter_idc  = h->deblocking_filter < 2 ? !h->deblocking_filter : h->deblocking_filter;
+    slice_param->slice_alpha_c0_offset_div2     = h->slice_alpha_c0_offset / 2;
+    slice_param->slice_beta_offset_div2         = h->slice_beta_offset / 2;
+    slice_param->luma_log2_weight_denom         = h->luma_log2_weight_denom;
+    slice_param->chroma_log2_weight_denom       = h->chroma_log2_weight_denom;
+
+    fill_vaapi_RefPicList(slice_param->RefPicList0, h->ref_list[0], h->list_count > 0 ? h->ref_count[0] : 0);
+    fill_vaapi_RefPicList(slice_param->RefPicList1, h->ref_list[1], h->list_count > 1 ? h->ref_count[1] : 0);
+
+    fill_vaapi_plain_pred_weight_table(h, 0,
+                                       &slice_param->luma_weight_l0_flag,   slice_param->luma_weight_l0,   slice_param->luma_offset_l0,
+                                       &slice_param->chroma_weight_l0_flag, slice_param->chroma_weight_l0, slice_param->chroma_offset_l0);
+    fill_vaapi_plain_pred_weight_table(h, 1,
+                                       &slice_param->luma_weight_l1_flag,   slice_param->luma_weight_l1,   slice_param->luma_offset_l1,
+                                       &slice_param->chroma_weight_l1_flag, slice_param->chroma_weight_l1, slice_param->chroma_offset_l1);
+    return 0;
+}
+
+AVHWAccel h264_vaapi_hwaccel = {
+    .name           = "h264_vaapi",
+    .type           = CODEC_TYPE_VIDEO,
+    .id             = CODEC_ID_H264,
+    .pix_fmt        = PIX_FMT_VAAPI_VLD,
+    .capabilities   = 0,
+    .start_frame    = start_frame,
+    .end_frame      = end_frame,
+    .decode_slice   = decode_slice,
+    .priv_data_size = 0,
+};
diff --git a/libavcodec/x86/dsputil_mmx.c b/libavcodec/x86/dsputil_mmx.c
index af33707..cae7084 100644
--- a/libavcodec/x86/dsputil_mmx.c
+++ b/libavcodec/x86/dsputil_mmx.c
@@ -2665,7 +2665,9 @@ void dsputil_init_mmx(DSPContext* c, AVCodecContext *avctx)
         c->add_pixels_clamped = add_pixels_clamped_mmx;
         c->clear_block  = clear_block_mmx;
         c->clear_blocks = clear_blocks_mmx;
-        if (mm_flags & FF_MM_SSE){
+        if ((mm_flags & FF_MM_SSE) &&
+            !(CONFIG_MPEG_XVMC_DECODER && avctx->xvmc_acceleration > 1)){
+            /* XvMCCreateBlocks() may not allocate 16-byte aligned blocks */
             c->clear_block  = clear_block_sse;
             c->clear_blocks = clear_blocks_sse;
         }
diff --git a/libmpcodecs/dec_video.c b/libmpcodecs/dec_video.c
index 6d9eb97..a2ab62b 100644
--- a/libmpcodecs/dec_video.c
+++ b/libmpcodecs/dec_video.c
@@ -39,9 +39,47 @@ extern double vout_time_usage;
 int field_dominance=-1;
 
 int divx_quality=0;
+char *video_hwaccel_name=NULL;
 
 vd_functions_t* mpvdec=NULL;
 
+int get_video_hwaccel(void)
+{
+    static int video_hwaccel = -1;
+    if (video_hwaccel < 0) {
+        video_hwaccel = HWACCEL_NONE;
+        if (video_hwaccel_name) {
+            if (!strcmp(video_hwaccel_name,"xvmc"))
+                video_hwaccel = HWACCEL_XVMC;
+            else if (!strcmp(video_hwaccel_name,"vaapi"))
+                video_hwaccel = HWACCEL_VAAPI;
+            else if (!strcmp(video_hwaccel_name,"vdpau"))
+                video_hwaccel = HWACCEL_VDPAU;
+        }
+    }
+    return video_hwaccel;
+}
+
+const char *get_video_hwaccel_name(int hwaccel)
+{
+    switch (hwaccel) {
+    case HWACCEL_XVMC:  return "XvMC";
+    case HWACCEL_VAAPI: return "VA API";
+    case HWACCEL_VDPAU: return "VDPAU";
+    }
+    return NULL;
+}
+
+const char *get_video_hwaccel_short_name(int hwaccel)
+{
+    switch (hwaccel) {
+    case HWACCEL_XVMC:  return "xvmc";
+    case HWACCEL_VAAPI: return "vaapi";
+    case HWACCEL_VDPAU: return "vdpau";
+    }
+    return NULL;
+}
+
 int get_video_quality_max(sh_video_t *sh_video){
   vf_instance_t* vf=sh_video->vfilter;
   if(vf){
diff --git a/libmpcodecs/dec_video.h b/libmpcodecs/dec_video.h
index 7a08a04..aa9e8ae 100644
--- a/libmpcodecs/dec_video.h
+++ b/libmpcodecs/dec_video.h
@@ -3,6 +3,14 @@
 
 #include "libmpdemux/stheader.h"
 
+enum {
+  HWACCEL_NONE = 0,
+  HWACCEL_XVMC,
+  HWACCEL_VAAPI,
+  HWACCEL_VDPAU,
+  HWACCEL_COUNT
+};
+
 // dec_video.c:
 void vfm_help(void);
 
@@ -21,6 +29,11 @@ int set_rectangle(sh_video_t *sh_video, int param, int value);
 void resync_video_stream(sh_video_t *sh_video);
 int get_current_video_decoder_lag(sh_video_t *sh_video);
 
+int get_video_hwaccel(void);
+const char *get_video_hwaccel_name(int hwaccel);
+const char *get_video_hwaccel_short_name(int hwaccel);
+
 extern int divx_quality;
+extern char *video_hwaccel_name;
 
 #endif /* MPLAYER_DEC_VIDEO_H */
diff --git a/libmpcodecs/img_format.c b/libmpcodecs/img_format.c
index 4704cf2..dd82646 100644
--- a/libmpcodecs/img_format.c
+++ b/libmpcodecs/img_format.c
@@ -69,6 +69,14 @@ const char *vo_format_name(int format)
 	case IMGFMT_ZRMJPEGIB: return "Zoran MJPEG bottom field first";
 	case IMGFMT_XVMC_MOCO_MPEG2: return "MPEG1/2 Motion Compensation";
 	case IMGFMT_XVMC_IDCT_MPEG2: return "MPEG1/2 Motion Compensation and IDCT";
+        case IMGFMT_VAAPI_MPEG2: return "MPEG-2 VA API Acceleration";
+        case IMGFMT_VAAPI_MPEG2_IDCT: return "MPEG-2 VA API Acceleration (Motion Compensation and IDCT)";
+        case IMGFMT_VAAPI_MPEG2_MOCO: return "MPEG-2 VA API Acceleration (Motion Compensation)";
+        case IMGFMT_VAAPI_MPEG4: return "MPEG-4 VA API Acceleration";
+        case IMGFMT_VAAPI_H263:  return "H.263 VA API Acceleration";
+        case IMGFMT_VAAPI_H264:  return "H.264 VA API Acceleration";
+        case IMGFMT_VAAPI_WMV3:  return "WMV3 VA API Acceleration";
+        case IMGFMT_VAAPI_VC1:   return "VC-1 VA API Acceleration";
 	case IMGFMT_VDPAU_MPEG1: return "MPEG1 VDPAU acceleration";
 	case IMGFMT_VDPAU_MPEG2: return "MPEG2 VDPAU acceleration";
 	case IMGFMT_VDPAU_H264: return "H.264 VDPAU acceleration";
diff --git a/libmpcodecs/img_format.h b/libmpcodecs/img_format.h
index 12a9ef7..62d7ab0 100644
--- a/libmpcodecs/img_format.h
+++ b/libmpcodecs/img_format.h
@@ -111,6 +111,26 @@
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
 
+/* VA API Formats */
+
+#define IMGFMT_VAAPI               0x56410000 /* 'VA'00 */
+#define IMGFMT_VAAPI_MASK          0xFFFF0000
+#define IMGFMT_IS_VAAPI(fmt)       (((fmt) & IMGFMT_VAAPI_MASK) == IMGFMT_VAAPI)
+#define IMGFMT_VAAPI_CODEC_MASK    0x000000F0
+#define IMGFMT_VAAPI_CODEC(fmt)    ((fmt) & IMGFMT_VAAPI_CODEC_MASK)
+#define IMGFMT_VAAPI_CODEC_MPEG2   (0x10)
+#define IMGFMT_VAAPI_CODEC_MPEG4   (0x20)
+#define IMGFMT_VAAPI_CODEC_H264    (0x30)
+#define IMGFMT_VAAPI_CODEC_VC1     (0x40)
+#define IMGFMT_VAAPI_MPEG2         (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG2)
+#define IMGFMT_VAAPI_MPEG2_IDCT    (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG2|1)
+#define IMGFMT_VAAPI_MPEG2_MOCO    (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG2|2)
+#define IMGFMT_VAAPI_MPEG4         (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG4)
+#define IMGFMT_VAAPI_H263          (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_MPEG4|1)
+#define IMGFMT_VAAPI_H264          (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_H264)
+#define IMGFMT_VAAPI_VC1           (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_VC1)
+#define IMGFMT_VAAPI_WMV3          (IMGFMT_VAAPI|IMGFMT_VAAPI_CODEC_VC1|1)
+
 // VDPAU specific format.
 #define IMGFMT_VDPAU               0x1DC80000
 #define IMGFMT_VDPAU_MASK          0xFFFF0000
diff --git a/libmpcodecs/mp_image.h b/libmpcodecs/mp_image.h
index ddf52c7..1e44211 100644
--- a/libmpcodecs/mp_image.h
+++ b/libmpcodecs/mp_image.h
@@ -111,6 +111,7 @@ static inline void mp_image_setfmt(mp_image_t* mpi,unsigned int out_fmt){
     // compressed formats
     if(out_fmt == IMGFMT_MPEGPES ||
        out_fmt == IMGFMT_ZRMJPEGNI || out_fmt == IMGFMT_ZRMJPEGIT || out_fmt == IMGFMT_ZRMJPEGIB ||
+       IMGFMT_IS_VAAPI(out_fmt) ||
        IMGFMT_IS_VDPAU(out_fmt) || IMGFMT_IS_XVMC(out_fmt)){
 	mpi->bpp=0;
 	return;
diff --git a/libmpcodecs/vd.c b/libmpcodecs/vd.c
index 3de3c15..1c354c5 100644
--- a/libmpcodecs/vd.c
+++ b/libmpcodecs/vd.c
@@ -348,3 +348,12 @@ void mpcodecs_draw_slice(sh_video_t *sh, unsigned char** src, int* stride, int w
   if(vf->draw_slice)
     vf->draw_slice(vf,src,stride,w,h,x,y);
 }
+
+void *mpcodecs_get_hwaccel_context(sh_video_t *sh)
+{
+    void *ctx = NULL;
+    struct vf_instance_s *vf = sh->vfilter;
+    if (vf->control(vf, VFCTRL_GET_HWACCEL_CONTEXT, &ctx) == CONTROL_TRUE)
+        return ctx;
+    return NULL;
+}
diff --git a/libmpcodecs/vd.h b/libmpcodecs/vd.h
index f05241b..31a804c 100644
--- a/libmpcodecs/vd.h
+++ b/libmpcodecs/vd.h
@@ -34,6 +34,7 @@ extern int vd_use_slices;
 int mpcodecs_config_vo(sh_video_t *sh, int w, int h, unsigned int preferred_outfmt);
 mp_image_t* mpcodecs_get_image(sh_video_t *sh, int mp_imgtype, int mp_imgflag, int w, int h);
 void mpcodecs_draw_slice(sh_video_t *sh, unsigned char** src, int* stride, int w,int h, int x, int y);
+void *mpcodecs_get_hwaccel_context(sh_video_t *sh);
 
 #define VDFLAGS_DROPFRAME 3
 
diff --git a/libmpcodecs/vd_ffmpeg.c b/libmpcodecs/vd_ffmpeg.c
index d2d7c84..773b070 100644
--- a/libmpcodecs/vd_ffmpeg.c
+++ b/libmpcodecs/vd_ffmpeg.c
@@ -14,6 +14,7 @@
 #include "fmt-conversion.h"
 
 #include "vd_internal.h"
+#include "dec_video.h"
 
 static vd_info_t info = {
     "FFmpeg's libavcodec codec family",
@@ -202,8 +203,8 @@ void mp_msp_av_log_callback(void *ptr, int level, const char *fmt, va_list vl)
 
 static void set_format_params(struct AVCodecContext *avctx, enum PixelFormat fmt){
     int imgfmt;
-    imgfmt = pixfmt2imgfmt(fmt);
-    if (IMGFMT_IS_XVMC(imgfmt) || IMGFMT_IS_VDPAU(imgfmt)) {
+    imgfmt = pixfmt2imgfmt(fmt, avctx->codec_id);
+    if (IMGFMT_IS_XVMC(imgfmt) || IMGFMT_IS_VDPAU(imgfmt) || IMGFMT_IS_VAAPI(imgfmt)) {
         sh_video_t *sh     = avctx->opaque;
         vd_ffmpeg_ctx *ctx = sh->context;
         ctx->do_dr1    = 1;
@@ -260,6 +261,12 @@ static int init(sh_video_t *sh){
     avctx->codec_type = CODEC_TYPE_VIDEO;
     avctx->codec_id = lavc_codec->id;
 
+#if CONFIG_VAAPI
+    if(get_video_hwaccel() == HWACCEL_VAAPI){
+        mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_VAAPIAcceleratedCodec);
+        avctx->get_format = get_format;
+    }
+#endif /* CONFIG_VAAPI */
 #if CONFIG_VDPAU
     if(lavc_codec->capabilities & CODEC_CAP_HWACCEL_VDPAU){
         avctx->get_format = get_format;
@@ -453,7 +460,7 @@ static void draw_slice(struct AVCodecContext *s,
                         AVFrame *src, int offset[4],
                         int y, int type, int height){
     sh_video_t *sh = s->opaque;
-    uint8_t *source[MP_MAX_PLANES]= {src->data[0] + offset[0], src->data[1] + offset[1], src->data[2] + offset[2]};
+    uint8_t *source[MP_MAX_PLANES]= {src->data[0] + offset[0], src->data[1] + offset[1], src->data[2] + offset[2], src->data[3] + offset[3]};
 #if 0
     int start=0, i;
     int width= s->width;
@@ -519,9 +526,10 @@ static int init_vo(sh_video_t *sh, enum PixelFormat pix_fmt){
         sh->disp_w = width;
         sh->disp_h = height;
         ctx->pix_fmt = pix_fmt;
-        ctx->best_csp = pixfmt2imgfmt(pix_fmt);
+        ctx->best_csp = pixfmt2imgfmt(pix_fmt, avctx->codec_id);
         if (!mpcodecs_config_vo(sh, sh->disp_w, sh->disp_h, ctx->best_csp))
             return -1;
+        avctx->hwaccel_context = mpcodecs_get_hwaccel_context(sh);
         ctx->vo_initialized = 1;
     }
     return 0;
@@ -574,7 +582,9 @@ static int get_buffer(AVCodecContext *avctx, AVFrame *pic){
         return avctx->get_buffer(avctx, pic);
     }
 
-    if (IMGFMT_IS_XVMC(ctx->best_csp) || IMGFMT_IS_VDPAU(ctx->best_csp)) {
+    if (IMGFMT_IS_XVMC(ctx->best_csp) ||
+        IMGFMT_IS_VAAPI(ctx->best_csp) ||
+        IMGFMT_IS_VDPAU(ctx->best_csp)) {
         type =  MP_IMGTYPE_NUMBERED | (0xffff << 16);
     } else
     if (!pic->buffer_hints) {
@@ -605,6 +615,11 @@ static int get_buffer(AVCodecContext *avctx, AVFrame *pic){
         avctx->draw_horiz_band= draw_slice;
     } else
         avctx->draw_horiz_band= NULL;
+#if CONFIG_VAAPI
+    if(IMGFMT_IS_VAAPI(mpi->imgfmt)) {
+        avctx->draw_horiz_band= draw_slice;
+    }
+#endif
     if(IMGFMT_IS_VDPAU(mpi->imgfmt)) {
         avctx->draw_horiz_band= draw_slice;
     }
@@ -639,6 +654,7 @@ static int get_buffer(AVCodecContext *avctx, AVFrame *pic){
     pic->data[0]= mpi->planes[0];
     pic->data[1]= mpi->planes[1];
     pic->data[2]= mpi->planes[2];
+    pic->data[3]= mpi->planes[3];
 
 #if 0
     assert(mpi->width >= ((width +align)&(~align)));
@@ -663,6 +679,7 @@ static int get_buffer(AVCodecContext *avctx, AVFrame *pic){
     pic->linesize[0]= mpi->stride[0];
     pic->linesize[1]= mpi->stride[1];
     pic->linesize[2]= mpi->stride[2];
+    pic->linesize[3]= mpi->stride[3];
 
     pic->opaque = mpi;
 //printf("%X\n", (int)mpi->planes[0]);
@@ -884,9 +901,11 @@ static mp_image_t *decode(sh_video_t *sh, void *data, int len, int flags){
         mpi->planes[0]=pic->data[0];
         mpi->planes[1]=pic->data[1];
         mpi->planes[2]=pic->data[2];
+        mpi->planes[3]=pic->data[3];
         mpi->stride[0]=pic->linesize[0];
         mpi->stride[1]=pic->linesize[1];
         mpi->stride[2]=pic->linesize[2];
+        mpi->stride[3]=pic->linesize[3];
     }
 
     if (!mpi->planes[0])
@@ -916,24 +935,62 @@ static mp_image_t *decode(sh_video_t *sh, void *data, int len, int flags){
     return mpi;
 }
 
-#if CONFIG_XVMC || CONFIG_VDPAU
+#if CONFIG_XVMC || CONFIG_VAAPI || CONFIG_VDPAU
+static inline int is_hwaccel_format(int imgfmt)
+{
+    switch (get_video_hwaccel()) {
+    case HWACCEL_VAAPI: return IMGFMT_IS_VAAPI(imgfmt) != 0;
+    case HWACCEL_VDPAU: return IMGFMT_IS_VDPAU(imgfmt) != 0;
+    case HWACCEL_XVMC:  return IMGFMT_IS_XVMC(imgfmt)  != 0;
+    }
+    return 0;
+}
+
+static int query_format(sh_video_t *sh, int fmt)
+{
+    vd_ffmpeg_ctx * const ctx = sh->context;
+    AVCodecContext * const avctx = ctx->avctx;
+    int r, width, height;
+    /* XXX: some codecs have not initialized width and height yet at
+       this point, so we are faking the dimensions so that init_vo()
+       doesn't fail because of 0x0 size */
+    if ((width = avctx->width) == 0)
+        avctx->width = 64;
+    if ((height = avctx->height) == 0)
+        avctx->height = 64;
+    r = init_vo(sh, fmt);
+    avctx->width = width;
+    avctx->height = height;
+    return r;
+}
+
 static enum PixelFormat get_format(struct AVCodecContext *avctx,
-                                    const enum PixelFormat *fmt){
-    enum PixelFormat selected_format;
+                                   const enum PixelFormat *fmt){
+    enum PixelFormat selected_format = PIX_FMT_NONE;
     int imgfmt;
     sh_video_t *sh = avctx->opaque;
-    int i;
-
-    for(i=0;fmt[i]!=PIX_FMT_NONE;i++){
-        imgfmt = pixfmt2imgfmt(fmt[i]);
-        if(!IMGFMT_IS_XVMC(imgfmt) && !IMGFMT_IS_VDPAU(imgfmt)) continue;
-        mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_TryingPixfmt, i);
-        if(init_vo(sh, fmt[i]) >= 0) {
-            break;
+    int i, try_hwaccel;
+
+    for (try_hwaccel = 1; try_hwaccel >= 0; --try_hwaccel) {
+        for (i = 0; fmt[i] != PIX_FMT_NONE; i++){
+            imgfmt = pixfmt2imgfmt(fmt[i], avctx->codec_id);
+            if ((try_hwaccel ^ is_hwaccel_format(imgfmt)) != 0)
+                continue;
+            mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_TryingPixfmt, i);
+            if (query_format(sh, fmt[i]) >= 0) {
+                if (try_hwaccel) {
+                    /* don't allow format conversion for HW acceleration */
+                    if (sh->codec->outfmt[sh->outfmtidx] != imgfmt)
+                        continue;
+                }
+                selected_format = fmt[i];
+                break;
+            }
         }
+        if (selected_format != PIX_FMT_NONE)
+            break;
     }
-    selected_format = fmt[i];
     set_format_params(avctx, selected_format);
     return selected_format;
 }
-#endif /* CONFIG_XVMC || CONFIG_VDPAU */
+#endif /* CONFIG_XVMC || CONFIG_VAAPI || CONFIG_VDPAU */
diff --git a/libmpcodecs/vf.h b/libmpcodecs/vf.h
index 67c2272..01301c2 100644
--- a/libmpcodecs/vf.h
+++ b/libmpcodecs/vf.h
@@ -89,6 +89,7 @@ typedef struct vf_seteq_s
 #define VFCTRL_GET_PTS         17 /* Return last pts value that reached vf_vo*/
 #define VFCTRL_SET_DEINTERLACE 18 /* Set deinterlacing status */
 #define VFCTRL_GET_DEINTERLACE 19 /* Get deinterlacing status */
+#define VFCTRL_GET_HWACCEL_CONTEXT 20 /* Get HW accelerator context */
 
 #include "vfcap.h"
 
diff --git a/libmpcodecs/vf_vo.c b/libmpcodecs/vf_vo.c
index affffa6..02b251e 100644
--- a/libmpcodecs/vf_vo.c
+++ b/libmpcodecs/vf_vo.c
@@ -151,6 +151,12 @@ static int control(struct vf_instance_s* vf, int request, void* data)
 	*(double *)data = vf->priv->pts;
 	return CONTROL_TRUE;
     }
+    case VFCTRL_GET_HWACCEL_CONTEXT:
+    {
+        if(!video_out) return CONTROL_FALSE; // vo not configured?
+        return(video_out->control(VOCTRL_GET_HWACCEL_CONTEXT, data)
+               == VO_TRUE) ? CONTROL_TRUE : CONTROL_FALSE;
+    }
     }
     // return video_out->control(request,data);
     return CONTROL_UNKNOWN;
@@ -170,6 +176,7 @@ static void get_image(struct vf_instance_s* vf,
     if(!vo_config_count) return;
     // GET_IMAGE is required for hardware-accelerated formats
     if(vo_directrendering ||
+       IMGFMT_IS_VAAPI(mpi->imgfmt) ||
        IMGFMT_IS_XVMC(mpi->imgfmt) || IMGFMT_IS_VDPAU(mpi->imgfmt))
 	video_out->control(VOCTRL_GET_IMAGE,mpi);
 }
diff --git a/libvo/stats.c b/libvo/stats.c
new file mode 100644
index 0000000..c4ff0ca
--- /dev/null
+++ b/libvo/stats.c
@@ -0,0 +1,217 @@
+#include "config.h"
+#include "stats.h"
+#include <time.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <locale.h>
+#include <inttypes.h>
+
+#if CONFIG_LIBGTOP
+#include <glibtop/cpu.h>
+#include <glibtop/proctime.h>
+#include <glibtop/procstate.h>
+#endif
+
+// Process statistics
+struct proc_stats {
+    uint64_t utime;
+    uint64_t stime;
+    uint64_t cutime;
+    uint64_t cstime;
+    uint64_t frequency;
+    uint64_t cpu_time;
+    uint64_t start_time;
+    uint64_t current_time;
+};
+
+// Get current process stats
+static int get_proc_stats(struct proc_stats *pstats);
+
+void stats_init(void)
+{
+#if CONFIG_LIBGTOP
+    glibtop_init();
+#endif
+}
+
+void stats_exit(void)
+{
+#if CONFIG_LIBGTOP
+    glibtop_close();
+#endif
+}
+
+// Get CPU frequency
+unsigned int get_cpu_frequency(void)
+{
+    unsigned int freq = 0;
+#if defined __linux__
+    {
+        FILE *proc_file = fopen("/proc/cpuinfo", "r");
+        if (proc_file) {
+            char line[256];
+            char *old_locale = setlocale(LC_NUMERIC, NULL);
+            setlocale(LC_NUMERIC, "C");
+            while(fgets(line, sizeof(line), proc_file)) {
+                float f;
+                int len = strlen(line);
+                if (len == 0)
+                    continue;
+                line[len - 1] = 0;
+                if (sscanf(line, "cpu MHz : %f", &f) == 1)
+                    freq = (unsigned int)f;
+            }
+            setlocale(LC_NUMERIC, old_locale);
+            fclose(proc_file);
+        }
+    }
+#endif
+    return freq;
+}
+
+// Get CPU usage in percent
+static float get_cpu_usage_1(void)
+{
+    static struct proc_stats prev_stats;
+    struct proc_stats curr_stats;
+    uint64_t prev_proc_time = 0, curr_proc_time = 0;
+    float pcpu = 0.0f;
+
+    if (get_proc_stats(&curr_stats) == 0) {
+        prev_proc_time += prev_stats.utime;
+        prev_proc_time += prev_stats.stime;
+        prev_proc_time += prev_stats.cutime;
+        prev_proc_time += prev_stats.cstime;
+        curr_proc_time += curr_stats.utime;
+        curr_proc_time += curr_stats.stime;
+        curr_proc_time += curr_stats.cutime;
+        curr_proc_time += curr_stats.cstime;
+        if (prev_stats.start_time > 0)
+            pcpu = 100.0 * ((float)(curr_proc_time - prev_proc_time) /
+                            (float)(curr_stats.cpu_time - prev_stats.cpu_time));
+        prev_stats = curr_stats;
+    }
+    return pcpu;
+}
+
+float get_cpu_usage(enum CpuUsageType type)
+{
+    static float pcpu_total = 0.0;
+    static unsigned int n_samples;
+    float pcpu;
+
+    pcpu        = get_cpu_usage_1();
+    pcpu_total += pcpu / 100.0;
+    ++n_samples;
+
+    if (type == CPU_USAGE_AVERAGE)
+        pcpu = 100.0 * (pcpu_total / n_samples);
+    return pcpu;
+}
+
+// For ELF executable, notes are pushed before environment and args
+static int find_elf_note(unsigned long match, unsigned long *pval)
+{
+    unsigned long *ep = (unsigned long *)__environ;
+    while (*ep++);
+    for (; *ep != 0; ep += 2) {
+        if (ep[0] == match) {
+            *pval = ep[1];
+            return 0;
+        }
+    }
+    return -1;
+}
+
+#ifndef AT_CLKTCK
+#define AT_CLKTCK 17
+#endif
+
+// Get current process stats
+int get_proc_stats(struct proc_stats *pstats)
+{
+    int error = -1;
+    char line[256], *str, *end;
+    char vc;
+    int vi;
+    unsigned long vul;
+    unsigned long long vull;
+    float vf;
+#if defined __linux__
+    {
+        FILE *proc_file = fopen("/proc/self/stat", "r");
+        if (proc_file) {
+            if (fgets(line, sizeof(line), proc_file)) {
+                unsigned long utime, stime, cutime, cstime, start_time;
+                str = strrchr(line, ')');
+                if (str && sscanf(str + 2,
+                                  "%c "
+                                  "%d %d %d %d %d "
+                                  "%lu %lu %lu %lu %lu %lu %lu "
+                                  "%ld %ld %ld %ld %ld %ld "
+                                  "%lu %lu ",
+                                  &vc,
+                                  &vi, &vi, &vi, &vi, &vi, 
+                                  &vul, &vul, &vul, &vul, &vul, &utime, &stime,
+                                  &cutime, &cstime, &vul, &vul, &vul, &vul,
+                                  &start_time, &vul) == 21) {
+                    pstats->utime      = utime;
+                    pstats->stime      = stime;
+                    pstats->cutime     = cutime;
+                    pstats->cstime     = cstime;
+                    pstats->start_time = start_time;
+                    error = 0;
+                }
+            }
+            fclose(proc_file);
+        }
+        if (error)
+            return error;
+        error = -1;
+
+        if (find_elf_note(AT_CLKTCK, &vul) == 0) {
+            pstats->frequency = vul;
+            error = 0;
+        }
+        if (error)
+            return error;
+        error = -1;
+
+        proc_file = fopen("/proc/uptime", "r");
+        if (proc_file) {
+            if (fgets(line, sizeof(line), proc_file)) {
+                char *old_locale = setlocale(LC_NUMERIC, NULL);
+                setlocale(LC_NUMERIC, "C");
+                if (sscanf(line, "%f", &vf) == 1) {
+                    pstats->cpu_time = (uint64_t)(vf * (float)pstats->frequency);
+                    error = 0;
+                }
+                setlocale(LC_NUMERIC, old_locale);
+            }
+            fclose(proc_file);
+        }
+    }
+#elif CONFIG_LIBGTOP
+    {
+        glibtop_cpu cpu;
+        glibtop_proc_time proc_time;
+        glibtop_proc_state proc_state;
+
+        glibtop_get_cpu(&cpu);
+        glibtop_get_proc_state(&proc_state, getpid());
+        pstats->cpu_time   = cpu.xcpu_total[proc_state.processor];
+
+        glibtop_get_proc_time(&proc_time, getpid());
+        pstats->utime      = proc_time.utime;
+        pstats->stime      = proc_time.stime;
+        pstats->cutime     = proc_time.cutime;
+        pstats->cstime     = proc_time.cstime;
+        pstats->start_time = proc_time.start_time;
+        pstats->frequency  = proc_time.frequency;
+
+        error = 0;
+    }
+#endif
+    return error;
+}
diff --git a/libvo/stats.h b/libvo/stats.h
new file mode 100644
index 0000000..62e7412
--- /dev/null
+++ b/libvo/stats.h
@@ -0,0 +1,21 @@
+#ifndef MPLAYER_STATS_H
+#define MPLAYER_STATS_H
+
+#include <stdint.h>
+
+void stats_init(void);
+void stats_exit(void);
+
+/// CPU usage model
+enum CpuUsageType {
+    CPU_USAGE_QUANTUM = 1, ///< CPU usage since the last call to cpu_get_usage()
+    CPU_USAGE_AVERAGE      ///< CPU usage average'd since program start
+};
+
+/// Get CPU frequency
+unsigned int get_cpu_frequency(void);
+
+/// Get CPU usage in percent
+float get_cpu_usage(enum CpuUsageType type);
+
+#endif /* MPLAYER_STATS_H */
diff --git a/libvo/video_out.c b/libvo/video_out.c
index e636902..bffbb98 100644
--- a/libvo/video_out.c
+++ b/libvo/video_out.c
@@ -132,6 +132,7 @@ extern vo_functions_t video_out_corevideo;
 extern vo_functions_t video_out_quartz;
 extern vo_functions_t video_out_pnm;
 extern vo_functions_t video_out_md5sum;
+extern vo_functions_t video_out_vaapi;
 
 const vo_functions_t* const video_out_drivers[] =
 {
@@ -274,6 +275,9 @@ const vo_functions_t* const video_out_drivers[] =
 #ifdef CONFIG_MD5SUM
         &video_out_md5sum,
 #endif
+#if CONFIG_VAAPI
+        &video_out_vaapi,
+#endif
         NULL
 };
 
diff --git a/libvo/video_out.h b/libvo/video_out.h
index ae38970..a882df2 100644
--- a/libvo/video_out.h
+++ b/libvo/video_out.h
@@ -97,6 +97,10 @@ typedef struct {
   int w,h;
 } mp_win_t;
 
+// Return current HW acceleration context
+// void *get_hwaccel_context(void);
+#define VOCTRL_GET_HWACCEL_CONTEXT 33
+
 #define VO_TRUE		1
 #define VO_FALSE	0
 #define VO_ERROR	-1
diff --git a/libvo/vo_vaapi.c b/libvo/vo_vaapi.c
new file mode 100644
index 0000000..e523089
--- /dev/null
+++ b/libvo/vo_vaapi.c
@@ -0,0 +1,1552 @@
+/*
+ * VA API output module
+ *
+ * Copyright (C) 2008-2009 Splitted-Desktop Systems
+ *
+ * This file is part of MPlayer.
+ *
+ * MPlayer is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * MPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with MPlayer; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+#include "subopt-helper.h"
+#include "video_out.h"
+#include "video_out_internal.h"
+#include "sub.h"
+#include "x11_common.h"
+#include "libavutil/common.h"
+#include "libavcodec/vaapi.h"
+#include "gui/interface.h"
+#include "stats.h"
+#include <stdarg.h>
+
+#if CONFIG_GL
+#include "gl_common.h"
+#include <GL/glu.h>
+#include <GL/glx.h>
+#endif
+
+#include <assert.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <va/va_x11.h>
+#if CONFIG_VAAPI_GLX
+#include <va/va_glx.h>
+#endif
+
+static vo_info_t info = {
+    "VA API with X11",
+    "vaapi",
+    "Gwenole Beauchesne <gbeauchesne@splitted-desktop.com>",
+    ""
+};
+
+LIBVO_EXTERN(vaapi)
+
+/* Numbers of video surfaces */
+#define MAX_OUTPUT_SURFACES       2 /* Maintain synchronisation points in flip_page() */
+#define MAX_VIDEO_SURFACES       21 /* Maintain free surfaces in a queue (use least-recently-used) */
+#define NUM_VIDEO_SURFACES_MPEG2  3 /* 1 decode frame, up to  2 references */
+#define NUM_VIDEO_SURFACES_MPEG4  3 /* 1 decode frame, up to  2 references */
+#define NUM_VIDEO_SURFACES_H264  21 /* 1 decode frame, up to 20 references */
+#define NUM_VIDEO_SURFACES_VC1    3 /* 1 decode frame, up to  2 references */
+
+typedef void (*draw_alpha_func)(int x0, int y0, int w, int h,
+                                unsigned char *src, unsigned char *srca,
+                                int stride);
+
+static int                      g_is_paused;
+static uint32_t                 g_image_width;
+static uint32_t                 g_image_height;
+static uint32_t                 g_image_format;
+static struct vo_rect           g_borders;
+static struct vo_rect           g_output_rect;
+static VASurfaceID              g_output_surfaces[MAX_OUTPUT_SURFACES];
+static unsigned int             g_output_surface;
+
+#if CONFIG_GL
+static int                      gl_enabled;
+static int                      gl_binding;
+static int                      gl_reflect;
+static GLuint                   gl_texture;
+static GLuint                   gl_font_base;
+#endif
+
+#if CONFIG_VAAPI_GLX
+static GLXContext               gl_context;
+static XVisualInfo             *gl_visual_info;
+static int                      gl_visual_attr[] = {
+    GLX_RGBA,
+    GLX_RED_SIZE, 1,
+    GLX_GREEN_SIZE, 1,
+    GLX_BLUE_SIZE, 1,
+    GLX_DOUBLEBUFFER,
+    GL_NONE
+};
+static void                    *gl_surface;
+#endif
+
+static struct vaapi_context    *va_context;
+static VAProfile               *va_profiles;
+static int                      va_num_profiles;
+static VAEntrypoint            *va_entrypoints;
+static int                      va_num_entrypoints;
+static VASurfaceID             *va_surface_ids;
+static int                      va_num_surfaces;
+static VASurfaceID            **va_free_surfaces;
+static int                      va_free_surfaces_head_index;
+static int                      va_free_surfaces_tail_index;
+static VAImageFormat           *va_image_formats;
+static int                      va_num_image_formats;
+static VAImageFormat           *va_subpic_formats;
+static unsigned int            *va_subpic_flags;
+static int                      va_num_subpic_formats;
+static VAImage                  va_osd_image;
+static uint8_t                 *va_osd_image_data;
+static struct vo_rect           va_osd_image_dirty_rect;
+static VASubpictureID           va_osd_subpicture;
+static int                      va_osd_associated;
+static draw_alpha_func          va_osd_draw_alpha;
+static uint8_t                 *va_osd_palette;
+
+///< Flag: direct surface mapping: use mpi->number to select free VA surface?
+static int                      va_dm;
+
+///< Flag: gather run-time statistics (CPU usage, frequency)
+static int                      cpu_stats;
+static unsigned int             cpu_frequency;
+static float                    cpu_usage;
+
+static int check_status(VAStatus status, const char *msg)
+{
+    if (status != VA_STATUS_SUCCESS) {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] %s: %s\n", msg, vaErrorStr(status));
+        return 0;
+    }
+    return 1;
+}
+
+static const char *string_of_VAImageFormat(VAImageFormat *imgfmt)
+{
+    static char str[5];
+    str[0] = imgfmt->fourcc;
+    str[1] = imgfmt->fourcc >> 8;
+    str[2] = imgfmt->fourcc >> 16;
+    str[3] = imgfmt->fourcc >> 24;
+    str[4] = '\0';
+    return str;
+}
+
+static const char *string_of_VAProfile(VAProfile profile)
+{
+    switch (profile) {
+#define PROFILE(profile) \
+        case VAProfile##profile: return "VAProfile" #profile
+        PROFILE(MPEG2Simple);
+        PROFILE(MPEG2Main);
+        PROFILE(MPEG4Simple);
+        PROFILE(MPEG4AdvancedSimple);
+        PROFILE(MPEG4Main);
+        PROFILE(H264Baseline);
+        PROFILE(H264Main);
+        PROFILE(H264High);
+        PROFILE(VC1Simple);
+        PROFILE(VC1Main);
+        PROFILE(VC1Advanced);
+#undef PROFILE
+    }
+    return "<unknown>";
+}
+
+static const char *string_of_VAEntrypoint(VAEntrypoint entrypoint)
+{
+    switch (entrypoint) {
+#define ENTRYPOINT(entrypoint) \
+        case VAEntrypoint##entrypoint: return "VAEntrypoint" #entrypoint
+        ENTRYPOINT(VLD);
+        ENTRYPOINT(IZZ);
+        ENTRYPOINT(IDCT);
+        ENTRYPOINT(MoComp);
+        ENTRYPOINT(Deblocking);
+#undef ENTRYPOINT
+    }
+    return "<unknown>";
+}
+
+static int has_profile(VAProfile profile)
+{
+    if (va_profiles && va_num_profiles > 0) {
+        int i;
+        for (i = 0; i < va_num_profiles; i++) {
+            if (va_profiles[i] == profile)
+                return 1;
+        }
+    }
+    return 0;
+}
+
+static int VAProfile_from_imgfmt(uint32_t format)
+{
+    static const int mpeg2_profiles[] =
+        { VAProfileMPEG2Main, VAProfileMPEG2Simple, -1 };
+    static const int mpeg4_profiles[] =
+        { VAProfileMPEG4Main, VAProfileMPEG4AdvancedSimple, VAProfileMPEG4Simple, -1 };
+    static const int h264_profiles[] =
+        { VAProfileH264High, VAProfileH264Main, VAProfileH264Baseline, -1 };
+    static const int wmv3_profiles[] =
+        { VAProfileVC1Main, VAProfileVC1Simple, -1 };
+    static const int vc1_profiles[] =
+        { VAProfileVC1Advanced, -1 };
+
+    const int *profiles = NULL;
+    switch (IMGFMT_VAAPI_CODEC(format)) {
+    case IMGFMT_VAAPI_CODEC_MPEG2:
+        profiles = mpeg2_profiles;
+        break;
+    case IMGFMT_VAAPI_CODEC_MPEG4:
+        profiles = mpeg4_profiles;
+        break;
+    case IMGFMT_VAAPI_CODEC_H264:
+        profiles = h264_profiles;
+        break;
+    case IMGFMT_VAAPI_CODEC_VC1:
+        switch (format) {
+        case IMGFMT_VAAPI_WMV3:
+            profiles = wmv3_profiles;
+            break;
+        case IMGFMT_VAAPI_VC1:
+            profiles = vc1_profiles;
+            break;
+        }
+        break;
+    }
+
+    if (profiles) {
+        for (int i = 0; profiles[i] != -1; i++) {
+            if (has_profile(profiles[i]))
+                return profiles[i];
+        }
+    }
+    return -1;
+}
+
+static int has_entrypoint(VAEntrypoint entrypoint)
+{
+    if (va_entrypoints && va_num_entrypoints > 0) {
+        int i;
+        for (i = 0; i < va_num_entrypoints; i++) {
+            if (va_entrypoints[i] == entrypoint)
+                return 1;
+        }
+    }
+    return 0;
+}
+
+static int VAEntrypoint_from_imgfmt(uint32_t format)
+{
+    int entrypoint = 0;
+    switch (format) {
+    case IMGFMT_VAAPI_MPEG2:
+    case IMGFMT_VAAPI_MPEG4:
+    case IMGFMT_VAAPI_H263:
+    case IMGFMT_VAAPI_H264:
+    case IMGFMT_VAAPI_WMV3:
+    case IMGFMT_VAAPI_VC1:
+        entrypoint = VAEntrypointVLD;
+        break;
+    case IMGFMT_VAAPI_MPEG2_IDCT:
+        entrypoint = VAEntrypointIDCT;
+        break;
+    case IMGFMT_VAAPI_MPEG2_MOCO:
+        entrypoint = VAEntrypointMoComp;
+        break;
+    }
+
+    if (entrypoint)
+        return has_entrypoint(entrypoint);
+
+    return -1;
+}
+
+static void resize(void)
+{
+    struct vo_rect src;
+
+    calc_src_dst_rects(g_image_width, g_image_height,
+                       &src, &g_output_rect, &g_borders, NULL);
+
+    vo_x11_clearwindow(mDisplay, vo_window);
+
+#if CONFIG_GL
+#define FOVY     60.0f
+#define ASPECT   1.0f
+#define Z_NEAR   0.1f
+#define Z_FAR    100.0f
+#define Z_CAMERA 0.869f
+
+    if (gl_enabled) {
+        glViewport(0, 0, vo_dwidth, vo_dheight);
+        glMatrixMode(GL_PROJECTION);
+        glLoadIdentity();
+        gluPerspective(FOVY, ASPECT, Z_NEAR, Z_FAR);
+        glMatrixMode(GL_MODELVIEW);
+        glLoadIdentity();
+
+        glTranslatef(-0.5f, -0.5f, -Z_CAMERA);
+        glScalef(1.0f / (GLfloat)vo_dwidth,
+                 -1.0f / (GLfloat)vo_dheight,
+                 1.0f / (GLfloat)vo_dwidth);
+        glTranslatef(0.0f, -1.0f * (GLfloat)vo_dheight, 0.0f);
+    }
+#endif
+
+    flip_page();
+}
+
+#if CONFIG_GL
+static int gl_build_font(void)
+{
+    XFontStruct *fi;
+
+    gl_font_base = glGenLists(96);
+
+    fi = XLoadQueryFont(mDisplay, "-adobe-helvetica-medium-r-normal--16-*-*-*-p-*-iso8859-1" );
+    if (!fi) {
+        fi = XLoadQueryFont(mDisplay, "fixed");
+        if (!fi)
+            return -1;
+    }
+
+    glXUseXFont(fi->fid, 32, 96, gl_font_base);
+    XFreeFont(mDisplay, fi);
+    return 0;
+}
+
+static void gl_printf(const char *format, ...)
+{
+    va_list args;
+    char *text;
+    int textlen;
+
+    va_start(args, format);
+    textlen = vsnprintf(NULL, 0, format, args);
+    va_end(args);
+
+    text = malloc(textlen + 1);
+    if (!text)
+        return;
+
+    va_start(args, format);
+    vsprintf(text, format, args);
+    va_end(args);
+
+    glPushAttrib(GL_LIST_BIT);
+    glListBase(gl_font_base - 32);
+    glCallLists(textlen, GL_UNSIGNED_BYTE, text);
+    glPopAttrib();
+    free(text);
+}
+
+static void gl_draw_rectangle(int x, int y, int w, int h, unsigned int rgba)
+{
+    glColor4f((GLfloat)((rgba >> 24) & 0xff) / 255.0,
+              (GLfloat)((rgba >> 16) & 0xff) / 255.0,
+              (GLfloat)((rgba >> 8) & 0xff) / 255.0,
+              (GLfloat)(rgba & 0xff) / 255.0);
+
+    glTranslatef((GLfloat)x, (GLfloat)y, 0.0f);
+    glBegin(GL_QUADS);
+    {
+        glVertex2i(0, 0);
+        glVertex2i(w, 0);
+        glVertex2i(w, h);
+        glVertex2i(0, h);
+    }
+    glEnd();
+}
+#endif
+
+static inline unsigned char *get_osd_image_data(int x0, int y0)
+{
+    return (va_osd_image_data +
+            va_osd_image.offsets[0] +
+            va_osd_image.pitches[0] * y0 +
+            x0 * ((va_osd_image.format.bits_per_pixel + 7) / 8));
+}
+
+static inline void set_osd_image_dirty_rect(int x, int y, int w, int h)
+{
+    struct vo_rect * const dirty_rect = &va_osd_image_dirty_rect;
+    dirty_rect->left   = x + w;
+    dirty_rect->top    = y + h;
+    dirty_rect->right  = x;
+    dirty_rect->bottom = y;
+    dirty_rect->width  = w;
+    dirty_rect->height = h;
+}
+
+static inline void update_osd_image_dirty_rect(int x, int y, int w, int h)
+{
+    struct vo_rect * const dirty_rect = &va_osd_image_dirty_rect;
+    dirty_rect->left   = FFMIN(dirty_rect->left,   x);
+    dirty_rect->top    = FFMIN(dirty_rect->top,    y);
+    dirty_rect->right  = FFMAX(dirty_rect->right,  x + w);
+    dirty_rect->bottom = FFMAX(dirty_rect->bottom, y + h);
+    dirty_rect->width  = dirty_rect->right - dirty_rect->left;
+    dirty_rect->height = dirty_rect->bottom - dirty_rect->top;
+}
+
+static void draw_alpha_rgb32(int x0, int y0, int w, int h,
+                             unsigned char *src, unsigned char *srca,
+                             int stride)
+{
+    update_osd_image_dirty_rect(x0, y0, w, h);
+
+    vo_draw_alpha_rgb32(w, h, src, srca, stride,
+                        va_osd_image_data +
+                        va_osd_image.offsets[0] +
+                        va_osd_image.pitches[0] * y0 + x0,
+                        va_osd_image.pitches[0]);
+}
+
+static void draw_alpha_IA44(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    update_osd_image_dirty_rect(x0, y0, w, h);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++)
+            dst[x] = (src[y*stride + x] & 0xf0) | (-srca[y*stride + x] >> 4);
+}
+
+static void draw_alpha_AI44(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    update_osd_image_dirty_rect(x0, y0, w, h);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++)
+            dst[x] = (src[y*stride + x] >> 4) | (-srca[y*stride + x] & 0xf0);
+}
+
+static void draw_alpha_IA88(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    update_osd_image_dirty_rect(x0, y0, w, h);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++) {
+            dst[2*x + 0] =  src [y*stride + x];
+            dst[2*x + 1] = -srca[y*stride + x];
+        }
+}
+
+static void draw_alpha_AI88(int x0, int y0, int w, int h,
+                            unsigned char *src, unsigned char *srca,
+                            int stride)
+{
+    int x, y;
+    const unsigned int dststride = va_osd_image.pitches[0];
+    unsigned char *dst = get_osd_image_data(x0, y0);
+
+    update_osd_image_dirty_rect(x0, y0, w, h);
+
+    for (y = 0; y < h; y++, dst += dststride)
+        for (x = 0; x < w; x++) {
+            dst[2*x + 0] = -srca[y*stride + x];
+            dst[2*x + 1] =  src [y*stride + x];
+        }
+}
+
+///< List of subpicture formats in preferred order
+static const struct {
+    uint32_t format;
+    draw_alpha_func draw_alpha;
+}
+va_osd_info[] = {
+    { VA_FOURCC('I','A','4','4'), draw_alpha_IA44  },
+    { VA_FOURCC('A','I','4','4'), draw_alpha_AI44  },
+    { VA_FOURCC('I','A','8','8'), draw_alpha_IA88  },
+    { VA_FOURCC('A','I','8','8'), draw_alpha_AI88  },
+    { VA_FOURCC('B','G','R','A'), draw_alpha_rgb32 },
+    { VA_FOURCC('R','G','B','A'), draw_alpha_rgb32 },
+    { 0, NULL }
+};
+
+static uint8_t *gen_osd_palette(const VAImage *image)
+{
+    uint8_t *palette;
+    int i, is_rgb;
+    int r_idx = -1, g_idx = -1, b_idx = -1;
+    int y_idx = -1, u_idx = -1, v_idx = -1;
+
+    if (image->num_palette_entries < 1)
+        return NULL;
+
+    palette = malloc(image->num_palette_entries * image->entry_bytes);
+    if (!palette)
+        return NULL;
+
+    for (i = 0; i < image->entry_bytes; i++) {
+        switch (image->component_order[i]) {
+        case 'R': r_idx = i; is_rgb = 1; break;
+        case 'G': g_idx = i; is_rgb = 1; break;
+        case 'B': b_idx = i; is_rgb = 1; break;
+        case 'Y': y_idx = i; is_rgb = 0; break;
+        case 'U': u_idx = i; is_rgb = 0; break;
+        case 'V': v_idx = i; is_rgb = 0; break;
+        }
+    }
+
+    if (r_idx != -1 && g_idx != -1 && b_idx != -1) {      /* RGB format */
+        for (i = 0; i < image->num_palette_entries; i++) {
+            const int n = i * image->entry_bytes;
+            palette[n + r_idx] = i * 0xff / (image->num_palette_entries - 1);
+            palette[n + g_idx] = i * 0xff / (image->num_palette_entries - 1);
+            palette[n + b_idx] = i * 0xff / (image->num_palette_entries - 1);
+        }
+    }
+    else if (y_idx != -1 && u_idx != -1 && v_idx != -1) { /* YUV format */
+        for (i = 0; i < image->num_palette_entries; i++) {
+            const int n = i * image->entry_bytes;
+            palette[n + y_idx] = i * 0xff / (image->num_palette_entries - 1);
+            palette[n + u_idx] = 0xff;
+            palette[n + v_idx] = 0xff;
+        }
+    }
+    else {
+        mp_msg(MSGT_VO, MSGL_ERR, "[vo_vaapi] Could not set up subpicture palette\n");
+        free(palette);
+        palette = NULL;
+    }
+    return palette;
+}
+
+static void disable_osd(void)
+{
+    if (!va_osd_associated)
+        return;
+
+    vaDeassociateSubpicture(va_context->display,
+                            va_osd_subpicture,
+                            va_surface_ids, va_num_surfaces);
+
+    va_osd_associated = 0;
+}
+
+static int enable_osd(const struct vo_rect *src_rect,
+                      const struct vo_rect *dst_rect)
+{
+    VAStatus status;
+
+    disable_osd();
+
+    status = vaAssociateSubpicture(va_context->display,
+                                   va_osd_subpicture,
+                                   va_surface_ids, va_num_surfaces,
+                                   src_rect->left,
+                                   src_rect->top,
+                                   src_rect->right - src_rect->left,
+                                   src_rect->bottom - src_rect->top,
+                                   dst_rect->left,
+                                   dst_rect->top,
+                                   dst_rect->right - dst_rect->left,
+                                   dst_rect->bottom - dst_rect->top,
+                                   0);
+    if (!check_status(status, "vaAssociateSubpicture()"))
+        return -1;
+
+    va_osd_associated = 1;
+    return 0;
+}
+
+static int is_direct_mapping_init(void)
+{
+    VADisplayAttribute attr;
+    VAStatus status;
+
+    if (va_dm < 2)
+        return va_dm;
+
+    /* If the driver doesn't make a copy of the VA surface for
+       display, then we have to retain it until it's no longer the
+       visible surface. In other words, if the driver is using
+       DirectSurface mode, we don't want to decode the new surface
+       into the previous one that was used for display. */
+    attr.type  = VADisplayAttribDirectSurface;
+    attr.flags = VA_DISPLAY_ATTRIB_GETTABLE;
+
+    status = vaGetDisplayAttributes(va_context->display, &attr, 1);
+    if (status == VA_STATUS_SUCCESS)
+        return !attr.value;
+    return 0;
+}
+
+static inline int is_direct_mapping(void)
+{
+    static int dm = -1;
+    if (dm < 0) {
+        dm = is_direct_mapping_init();
+        if (dm)
+            mp_msg(MSGT_VO, MSGL_INFO,
+                   "[vo_vaapi] Using 1:1 VA surface mapping\n");
+    }
+    return dm;
+}
+
+static int int_012(int *n)
+{
+    return *n >= 0 && *n <= 2;
+}
+
+static const opt_t subopts[] = {
+    { "dm",          OPT_ARG_INT,  &va_dm,        (opt_test_f)int_012 },
+    { "stats",       OPT_ARG_BOOL, &cpu_stats,    NULL },
+#if CONFIG_GL
+    { "gl",          OPT_ARG_BOOL, &gl_enabled,   NULL },
+    { "bind",        OPT_ARG_BOOL, &gl_binding,   NULL },
+    { "reflect",     OPT_ARG_BOOL, &gl_reflect,   NULL },
+#endif
+    { NULL, }
+};
+
+static int preinit(const char *arg)
+{
+    VAStatus status;
+    int va_major_version, va_minor_version;
+    int i, max_image_formats, max_subpic_formats, max_profiles;
+
+    va_dm = 2;
+    if (subopt_parse(arg, subopts) != 0) {
+        mp_msg(MSGT_VO, MSGL_FATAL,
+               "\n-vo vaapi command line help:\n"
+               "Example: mplayer -vo vaapi:gl\n"
+               "\nOptions:\n"
+               "  dm=0|1|2\n"
+               "    Use direct surface mapping (default: 2 - autodetect)\n"
+#if CONFIG_GL
+               "  gl\n"
+               "    Enable OpenGL rendering\n"
+               "  bind\n"
+               "    Use VA surface binding instead of copy\n"
+               "  reflect\n"
+               "    Enable OpenGL reflection effects\n"
+#endif
+               "\n" );
+        return -1;
+    }
+#if CONFIG_GL
+    if (gl_enabled)
+        mp_msg(MSGT_VO, MSGL_INFO, "[vo_vaapi] Using OpenGL rendering%s\n",
+               gl_reflect ? ", with reflection effects" : "");
+#endif
+
+    stats_init();
+
+    if (!vo_init())
+        return -1;
+
+    va_context = calloc(1, sizeof(*va_context));
+    if (!va_context)
+        return -1;
+
+#if CONFIG_VAAPI_GLX
+    if (gl_enabled)
+        va_context->display = vaGetDisplayGLX(mDisplay);
+    else
+#endif
+        va_context->display = vaGetDisplay(mDisplay);
+    if (!va_context->display)
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): VA display %p\n", va_context->display);
+
+    status = vaInitialize(va_context->display, &va_major_version, &va_minor_version);
+    if (!check_status(status, "vaInitialize()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): VA API version %d.%d\n",
+           va_major_version, va_minor_version);
+
+    max_image_formats = vaMaxNumImageFormats(va_context->display);
+    va_image_formats = calloc(max_image_formats, sizeof(*va_image_formats));
+    if (!va_image_formats)
+        return -1;
+    status = vaQueryImageFormats(va_context->display, va_image_formats, &va_num_image_formats);
+    if (!check_status(status, "vaQueryImageFormats()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): %d image formats available\n",
+           va_num_image_formats);
+    for (i = 0; i < va_num_image_formats; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s\n", string_of_VAImageFormat(&va_image_formats[i]));
+
+    max_subpic_formats = vaMaxNumSubpictureFormats(va_context->display);
+    va_subpic_formats = calloc(max_subpic_formats, sizeof(*va_subpic_formats));
+    if (!va_subpic_formats)
+        return -1;
+    va_subpic_flags = calloc(max_subpic_formats, sizeof(*va_subpic_flags));
+    if (!va_subpic_flags)
+        return -1;
+    status = vaQuerySubpictureFormats(va_context->display, va_subpic_formats, va_subpic_flags, &va_num_subpic_formats);
+    if (!check_status(status, "vaQuerySubpictureFormats()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): %d subpicture formats available\n",
+           va_num_subpic_formats);
+    for (i = 0; i < va_num_subpic_formats; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s, flags 0x%x\n", string_of_VAImageFormat(&va_subpic_formats[i]), va_subpic_flags[i]);
+
+    max_profiles = vaMaxNumProfiles(va_context->display);
+    va_profiles = calloc(max_profiles, sizeof(*va_profiles));
+    if (!va_profiles)
+        return -1;
+    status = vaQueryConfigProfiles(va_context->display, va_profiles, &va_num_profiles);
+    if (!check_status(status, "vaQueryConfigProfiles()"))
+        return -1;
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] preinit(): %d profiles available\n",
+           va_num_profiles);
+    for (i = 0; i < va_num_profiles; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s\n", string_of_VAProfile(va_profiles[i]));
+
+    va_osd_subpicture = VA_INVALID_ID;
+    va_osd_image.image_id = VA_INVALID_ID;
+    return 0;
+}
+
+static void free_video_specific(void)
+{
+#if CONFIG_VAAPI_GLX
+    if (gl_surface) {
+        VAStatus status;
+        status = vaDestroySurfaceGLX(va_context->display, gl_surface);
+        check_status(status, "vaDestroySurfaceGLX()");
+        gl_surface = NULL;
+    }
+#endif
+
+    if (va_context && va_context->context_id) {
+        vaDestroyContext(va_context->display, va_context->context_id);
+        va_context->context_id = 0;
+    }
+
+    if (va_free_surfaces) {
+        free(va_free_surfaces);
+        va_free_surfaces = NULL;
+    }
+
+    if (va_osd_palette) {
+        free(va_osd_palette);
+        va_osd_palette = NULL;
+    }
+
+    disable_osd();
+
+    if (va_osd_subpicture != VA_INVALID_ID) {
+        vaDestroySubpicture(va_context->display, va_osd_subpicture);
+        va_osd_subpicture = VA_INVALID_ID;
+    }
+
+    if (va_osd_image.image_id != VA_INVALID_ID) {
+        vaDestroyImage(va_context->display, va_osd_image.image_id);
+        va_osd_image.image_id = VA_INVALID_ID;
+    }
+
+    if (va_surface_ids) {
+        vaDestroySurfaces(va_context->display, va_surface_ids, va_num_surfaces);
+        free(va_surface_ids);
+        va_surface_ids = NULL;
+    }
+
+    if (va_context && va_context->config_id) {
+        vaDestroyConfig(va_context->display, va_context->config_id);
+        va_context->config_id = 0;
+    }
+
+    if (va_entrypoints) {
+        free(va_entrypoints);
+        va_entrypoints = NULL;
+    }
+
+#if CONFIG_GL
+    if (gl_texture) {
+        glDeleteTextures(1, &gl_texture);
+        gl_texture = GL_NONE;
+    }
+#endif
+
+#if CONFIG_VAAPI_GLX
+    if (gl_enabled) {
+        releaseGlContext(&gl_visual_info, &gl_context);
+        gl_visual_info = NULL;
+    }
+#endif
+}
+
+static void uninit(void)
+{
+    free_video_specific();
+
+    if (va_profiles) {
+        free(va_profiles);
+        va_profiles = NULL;
+    }
+
+    if (va_subpic_flags) {
+        free(va_subpic_flags);
+        va_subpic_flags = NULL;
+    }
+
+    if (va_subpic_formats) {
+        free(va_subpic_formats);
+        va_subpic_formats = NULL;
+    }
+
+    if (va_image_formats) {
+        free(va_image_formats);
+        va_image_formats = NULL;
+    }
+
+    if (va_context && va_context->display) {
+        vaTerminate(va_context->display);
+        va_context->display = NULL;
+    }
+
+    if (va_context) {
+        free(va_context);
+        va_context = NULL;
+    }
+
+#ifdef CONFIG_XF86VM
+    vo_vm_close();
+#endif
+    vo_x11_uninit();
+
+    stats_exit();
+}
+
+static int config_x11(uint32_t width, uint32_t height,
+                      uint32_t display_width, uint32_t display_height,
+                      uint32_t flags, char *title)
+{
+    Colormap cmap;
+    XVisualInfo visualInfo;
+    XVisualInfo *vi;
+    XSetWindowAttributes xswa;
+    unsigned long xswa_mask;
+    XWindowAttributes wattr;
+    int depth;
+
+#ifdef CONFIG_GUI
+    if (use_gui)
+        guiGetEvent(guiSetShVideo, 0);  // the GUI will set up / resize our window
+    else
+#endif
+    {
+#ifdef CONFIG_XF86VM
+        if (flags & VOFLAG_MODESWITCHING)
+            vo_vm_switch();
+#endif
+        XGetWindowAttributes(mDisplay, DefaultRootWindow(mDisplay), &wattr);
+        depth = wattr.depth;
+        if (depth != 15 && depth != 16 && depth != 24 && depth != 32)
+            depth = 24;
+        XMatchVisualInfo(mDisplay, mScreen, depth, TrueColor, &visualInfo);
+
+#if CONFIG_VAAPI_GLX
+        if (gl_enabled) {
+            vi = glXChooseVisual(mDisplay, mScreen, gl_visual_attr);
+            if (!vi)
+                return -1;
+            cmap = XCreateColormap(mDisplay, mRootWin, vi->visual, AllocNone);
+            if (cmap == None)
+                return -1;
+        }
+        else
+#endif
+        {
+            vi = &visualInfo;
+            XMatchVisualInfo(mDisplay, mScreen, depth, TrueColor, vi);
+            cmap = CopyFromParent;
+        }
+
+        vo_x11_create_vo_window(vi,
+                                vo_dx, vo_dy, display_width, display_height,
+                                flags, cmap, "vaapi", title);
+
+        if (vi != &visualInfo)
+            XFree(vi);
+
+        xswa_mask             = CWBorderPixel | CWBackPixel;
+        xswa.border_pixel     = 0;
+        xswa.background_pixel = 0;
+        XChangeWindowAttributes(mDisplay, vo_window, xswa_mask, &xswa);
+
+#ifdef CONFIG_XF86VM
+        if (flags & VOFLAG_MODESWITCHING) {
+            /* Grab the mouse pointer in our window */
+            if (vo_grabpointer)
+                XGrabPointer(mDisplay, vo_window, True, 0,
+                             GrabModeAsync, GrabModeAsync,
+                             vo_window, None, CurrentTime);
+            XSetInputFocus(mDisplay, vo_window, RevertToNone, CurrentTime);
+        }
+#endif
+    }
+
+    if ((flags & VOFLAG_FULLSCREEN) && WinID <= 0)
+        vo_fs = VO_TRUE;
+    return 0;
+}
+
+#if CONFIG_VAAPI_GLX
+static int config_glx(unsigned int width, unsigned int height)
+{
+    if (setGlWindow(&gl_visual_info, &gl_context, vo_window) < 0)
+        return -1;
+
+    glDisable(GL_DEPTH_TEST);
+    glDepthMask(GL_FALSE);
+    glDisable(GL_CULL_FACE);
+    glEnable(GL_TEXTURE_2D);
+    glDrawBuffer(vo_doublebuffering ? GL_BACK : GL_FRONT);
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+    /* Create OpenGL texture */
+    /* XXX: assume GL_ARB_texture_non_power_of_two is available */
+    glEnable(GL_TEXTURE_2D);
+    glGenTextures(1, &gl_texture);
+    BindTexture(GL_TEXTURE_2D, gl_texture);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0,
+                 GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+    BindTexture(GL_TEXTURE_2D, 0);
+    glDisable(GL_TEXTURE_2D);
+
+    glClearColor(0.0, 0.0, 0.0, 1.0);
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    if (gl_build_font() < 0)
+        return -1;
+    return 0;
+}
+#endif
+
+static int config_vaapi(uint32_t width, uint32_t height, uint32_t format)
+{
+    VAConfigAttrib attrib;
+    VAStatus status;
+    int i, j, profile, entrypoint, max_entrypoints;
+
+    /* Check profile */
+    profile = VAProfile_from_imgfmt(format);
+    if (profile < 0)
+        return -1;
+
+    /* Check entry-point (only VLD for now) */
+    max_entrypoints = vaMaxNumEntrypoints(va_context->display);
+    va_entrypoints = calloc(max_entrypoints, sizeof(*va_entrypoints));
+    if (!va_entrypoints)
+        return -1;
+
+    status = vaQueryConfigEntrypoints(va_context->display, profile,
+                                      va_entrypoints, &va_num_entrypoints);
+    if (!check_status(status, "vaQueryConfigEntrypoints()"))
+        return -1;
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] config_vaapi(%s): %d entrypoints available\n",
+           string_of_VAProfile(profile), va_num_entrypoints);
+    for (i = 0; i < va_num_entrypoints; i++)
+        mp_msg(MSGT_VO, MSGL_DBG2, "  %s\n", string_of_VAEntrypoint(va_entrypoints[i]));
+
+    entrypoint = VAEntrypoint_from_imgfmt(format);
+    if (entrypoint != VAEntrypointVLD)
+        return -1;
+
+    /* Check chroma format (only 4:2:0 for now) */
+    attrib.type = VAConfigAttribRTFormat;
+    status = vaGetConfigAttributes(va_context->display, profile, entrypoint, &attrib, 1);
+    if (!check_status(status, "vaGetConfigAttributes()"))
+        return -1;
+    if ((attrib.value & VA_RT_FORMAT_YUV420) == 0)
+        return -1;
+
+    /* Create a configuration for the decode pipeline */
+    status = vaCreateConfig(va_context->display, profile, entrypoint, &attrib, 1, &va_context->config_id);
+    if (!check_status(status, "vaCreateConfig()"))
+        return -1;
+
+    /* Create video surfaces */
+    switch (IMGFMT_VAAPI_CODEC(format)) {
+    case IMGFMT_VAAPI_CODEC_MPEG2:
+        va_num_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+        break;
+    case IMGFMT_VAAPI_CODEC_MPEG4:
+        va_num_surfaces = NUM_VIDEO_SURFACES_MPEG4;
+        break;
+    case IMGFMT_VAAPI_CODEC_H264:
+        va_num_surfaces = NUM_VIDEO_SURFACES_H264;
+        break;
+    case IMGFMT_VAAPI_CODEC_VC1:
+        va_num_surfaces = NUM_VIDEO_SURFACES_VC1;
+        break;
+    default:
+        va_num_surfaces = 0;
+        break;
+    }
+    if (va_num_surfaces == 0)
+        return -1;
+    if (!is_direct_mapping())
+        va_num_surfaces = FFMIN(2 * va_num_surfaces, MAX_VIDEO_SURFACES);
+
+    va_surface_ids = calloc(va_num_surfaces, sizeof(*va_surface_ids));
+    if (!va_surface_ids)
+        return -1;
+
+    status = vaCreateSurfaces(va_context->display, width, height, VA_RT_FORMAT_YUV420,
+                              va_num_surfaces, va_surface_ids);
+    if (!check_status(status, "vaCreateSurfaces()"))
+        return -1;
+
+    va_free_surfaces = calloc(va_num_surfaces, sizeof(*va_free_surfaces));
+    if (!va_free_surfaces)
+        return -1;
+    for (i = 0; i < va_num_surfaces; i++)
+        va_free_surfaces[i] = &va_surface_ids[i];
+
+    /* Create OSD data */
+    va_osd_draw_alpha     = NULL;
+    va_osd_image.image_id = VA_INVALID_ID;
+    va_osd_image.buf      = VA_INVALID_ID;
+    va_osd_subpicture     = VA_INVALID_ID;
+    for (i = 0; va_osd_info[i].format; i++) {
+        for (j = 0; j < va_num_subpic_formats; j++)
+            if (va_subpic_formats[j].fourcc == va_osd_info[i].format)
+                break;
+        if (j < va_num_subpic_formats &&
+            vaCreateImage(va_context->display, &va_subpic_formats[j],
+                          width, height, &va_osd_image) == VA_STATUS_SUCCESS)
+            break;
+    }
+    if (va_osd_info[i].format &&
+        vaCreateSubpicture(va_context->display, va_osd_image.image_id,
+                           &va_osd_subpicture) == VA_STATUS_SUCCESS) {
+        va_osd_draw_alpha = va_osd_info[i].draw_alpha;
+        va_osd_palette = gen_osd_palette(&va_osd_image);
+        if (va_osd_palette) {
+            status = vaSetImagePalette(va_context->display,
+                                       va_osd_image.image_id, va_osd_palette);
+            check_status(status, "vaSetImagePalette()");
+        }
+        mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] Using %s surface for OSD\n",
+               string_of_VAImageFormat(&va_osd_image.format));
+    }
+
+#if CONFIG_VAAPI_GLX
+    /* Create GLX surfaces */
+    if (gl_enabled) {
+        status = vaCreateSurfaceGLX(va_context->display,
+                                    GL_TEXTURE_2D, gl_texture,
+                                    &gl_surface);
+        if (!check_status(status, "vaCreateSurfaceGLX()"))
+            return -1;
+    }
+#endif
+
+    /* Create a context for the decode pipeline */
+    status = vaCreateContext(va_context->display, va_context->config_id,
+                             width, height, VA_PROGRESSIVE,
+                             va_surface_ids, va_num_surfaces,
+                             &va_context->context_id);
+    if (!check_status(status, "vaCreateContext()"))
+        return -1;
+
+    g_output_surface = 0;
+    for (i = 0; i < MAX_OUTPUT_SURFACES; i++)
+        g_output_surfaces[i] = VA_INVALID_SURFACE;
+    return 0;
+}
+
+static int config(uint32_t width, uint32_t height,
+                  uint32_t display_width, uint32_t display_height,
+                  uint32_t flags, char *title, uint32_t format)
+{
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] config(): size %dx%d, display size %dx%d, flags %x, title '%s', format %x (%s)\n",
+           width, height, display_width, display_height, flags, title, format, vo_format_name(format));
+
+    free_video_specific();
+
+    if (config_x11(width, height, display_width, display_height, flags, title) < 0)
+        return -1;
+
+#if CONFIG_VAAPI_GLX
+    if (gl_enabled && config_glx(width, height) < 0)
+        return -1;
+#endif
+
+    if (config_vaapi(width, height, format) < 0)
+        return -1;
+
+    g_is_paused    = 0;
+    g_image_width  = width;
+    g_image_height = height;
+    g_image_format = format;
+    resize();
+    return 0;
+}
+
+static int query_format(uint32_t format)
+{
+    const int default_caps = (VFCAP_CSP_SUPPORTED |
+                              VFCAP_CSP_SUPPORTED_BY_HW |
+                              VFCAP_HWSCALE_UP |
+                              VFCAP_HWSCALE_DOWN |
+                              VFCAP_OSD);
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] query_format(): format %x (%s)\n",
+           format, vo_format_name(format));
+
+    switch (format) {
+    case IMGFMT_VAAPI_MPEG2:
+    case IMGFMT_VAAPI_MPEG4:
+    case IMGFMT_VAAPI_H263:
+    case IMGFMT_VAAPI_H264:
+    case IMGFMT_VAAPI_WMV3:
+    case IMGFMT_VAAPI_VC1:
+        return default_caps | VOCAP_NOSLICES;
+    }
+    return 0;
+}
+
+static void put_surface_x11(VASurfaceID surface)
+{
+    VAStatus status;
+
+    status = vaPutSurface(va_context->display,
+                          surface,
+                          vo_window,
+                          0, 0, g_image_width, g_image_height,
+                          g_output_rect.left,
+                          g_output_rect.top,
+                          g_output_rect.width,
+                          g_output_rect.height,
+                          NULL, 0,
+                          VA_FRAME_PICTURE);
+    if (!check_status(status, "vaPutSurface()"))
+        return;
+}
+
+#if CONFIG_VAAPI_GLX
+static void put_surface_glx(VASurfaceID surface)
+{
+    VAStatus status;
+
+    if (surface == VA_INVALID_SURFACE)
+        return;
+
+    if (gl_binding) {
+        status = vaAssociateSurfaceGLX(va_context->display,
+                                       gl_surface,
+                                       surface,
+                                       VA_FRAME_PICTURE);
+        if (!check_status(status, "vaAssociateSurfaceGLX()"))
+            return;
+    }
+    else {
+        status = vaCopySurfaceGLX(va_context->display,
+                                  gl_surface,
+                                  surface,
+                                  VA_FRAME_PICTURE);
+        if (status == VA_STATUS_ERROR_UNIMPLEMENTED) {
+            mp_msg(MSGT_VO, MSGL_WARN,
+                   "[vo_vaapi] vaCopySurfaceGLX() is not implemented\n");
+            gl_binding = 1;
+        }
+        else {
+            if (!check_status(status, "vaCopySurfaceGLX()"))
+                return;
+        }
+    }
+    g_output_surfaces[g_output_surface] = surface;
+}
+
+static int glx_bind_texture(void)
+{
+    VAStatus status;
+
+    glEnable(GL_TEXTURE_2D);
+    BindTexture(GL_TEXTURE_2D, gl_texture);
+
+    if (gl_binding) {
+        status = vaBeginRenderSurfaceGLX(va_context->display, gl_surface);
+        if (!check_status(status, "vaBeginRenderSurfaceGLX()"))
+            return -1;
+    }
+    return 0;
+}
+
+static int glx_unbind_texture(void)
+{
+    VAStatus status;
+
+    if (gl_binding) {
+        status = vaEndRenderSurfaceGLX(va_context->display, gl_surface);
+        if (!check_status(status, "vaEndRenderSurfaceGLX()"))
+            return -1;
+    }
+
+    BindTexture(GL_TEXTURE_2D, 0);
+    glDisable(GL_TEXTURE_2D);
+    return 0;
+}
+
+static void render_background(void)
+{
+    /* Original code from Mirco Muller (MacSlow):
+       <http://cgit.freedesktop.org/~macslow/gl-gst-player/> */
+    GLfloat fStartX = 0.0f;
+    GLfloat fStartY = 0.0f;
+    GLfloat fWidth  = (GLfloat)vo_dwidth;
+    GLfloat fHeight = (GLfloat)vo_dheight;
+
+    glBegin(GL_QUADS);
+    {
+        /* top third, darker grey to white */
+        glColor3f(0.85f, 0.85f, 0.85f);
+        glVertex3f(fStartX, fStartY, 0.0f);
+        glColor3f(0.85f, 0.85f, 0.85f);
+        glVertex3f(fStartX + fWidth, fStartY, 0.0f);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX + fWidth, fStartY + fHeight / 3.0f, 0.0f);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX, fStartY + fHeight / 3.0f, 0.0f);
+
+        /* middle third, just plain white */
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX, fStartY + fHeight / 3.0f, 0.0f);
+        glVertex3f(fStartX + fWidth, fStartY + fHeight / 3.0f, 0.0f);
+        glVertex3f(fStartX + fWidth, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+        glVertex3f(fStartX, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+
+        /* bottom third, white to lighter grey */
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glVertex3f(fStartX + fWidth, fStartY + 2.0f * fHeight / 3.0f, 0.0f);
+        glColor3f(0.62f, 0.66f, 0.69f);
+        glVertex3f(fStartX + fWidth, fStartY + fHeight, 0.0f);
+        glColor3f(0.62f, 0.66f, 0.69f);
+        glVertex3f(fStartX, fStartY + fHeight, 0.0f);
+    }
+    glEnd();
+}
+
+static void render_frame(void)
+{
+    struct vo_rect * const r = &g_output_rect;
+
+    if (glx_bind_texture() < 0)
+        return;
+    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+    glBegin(GL_QUADS);
+    {
+        glTexCoord2f(0.0f, 0.0f); glVertex2i(r->left, r->top);
+        glTexCoord2f(0.0f, 1.0f); glVertex2i(r->left, r->bottom);
+        glTexCoord2f(1.0f, 1.0f); glVertex2i(r->right, r->bottom);
+        glTexCoord2f(1.0f, 0.0f); glVertex2i(r->right, r->top);
+    }
+    glEnd();
+    if (glx_unbind_texture() < 0)
+        return;
+}
+
+static void render_reflection(void)
+{
+    struct vo_rect * const r = &g_output_rect;
+    const unsigned int rh  = g_output_rect.height / 5;
+    GLfloat ry = 1.0f - (GLfloat)rh / (GLfloat)r->height;
+
+    if (glx_bind_texture() < 0)
+        return;
+    glBegin(GL_QUADS);
+    {
+        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+        glTexCoord2f(0.0f, 1.0f); glVertex2i(r->left, r->top);
+        glTexCoord2f(1.0f, 1.0f); glVertex2i(r->right, r->top);
+
+        glColor4f(1.0f, 1.0f, 1.0f, 0.0f);
+        glTexCoord2f(1.0f, ry); glVertex2i(r->right, r->top + rh);
+        glTexCoord2f(0.0f, ry); glVertex2i(r->left, r->top + rh);
+    }
+    glEnd();
+    if (glx_unbind_texture() < 0)
+        return;
+}
+
+static void flip_page_glx(void)
+{
+    VAStatus status;
+
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    if (gl_reflect) {
+        render_background();
+
+        glPushMatrix();
+        glRotatef(20.0f, 0.0f, 1.0f, 0.0f);
+        glTranslatef(50.0f, 0.0f, 0.0f);
+    }
+
+    render_frame();
+
+    if (gl_reflect) {
+        glPushMatrix();
+        glTranslatef(0.0, (GLfloat)g_output_rect.height + 5.0f, 0.0f);
+        render_reflection();
+        glPopMatrix();
+        glPopMatrix();
+    }
+
+    if (cpu_stats) {
+        gl_draw_rectangle(0, 0, vo_dwidth, 32, 0x000000ff);
+        glColor3f(1.0f, 1.0f, 1.0f);
+        glRasterPos2i(16, 20);
+        gl_printf("MPlayer: %.1f%% of CPU @ %u MHz", cpu_usage, cpu_frequency);
+    }
+
+    swapGlBuffers();
+
+    if (vo_fs) /* avoid flickering borders in fullscreen mode */
+        glClear(GL_COLOR_BUFFER_BIT);
+}
+#endif
+
+static void put_surface(VASurfaceID surface)
+{
+    if (surface == VA_INVALID_SURFACE)
+        return;
+
+#if CONFIG_VAAPI_GLX
+    if (gl_enabled)
+        put_surface_glx(surface);
+    else
+#endif
+        put_surface_x11(surface);
+}
+
+static int draw_slice(uint8_t * image[], int stride[],
+                      int w, int h, int x, int y)
+{
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] draw_slice(): location (%d,%d), size %dx%d\n", x, y, w, h);
+
+    return VO_TRUE;
+}
+
+static int draw_frame(uint8_t * src[])
+{
+    mp_msg(MSGT_VO,MSGL_INFO, MSGTR_LIBVO_X11_DrawFrameCalled);
+
+    return -1;
+}
+
+static void draw_osd(void)
+{
+    VAStatus status;
+
+    if (!va_osd_draw_alpha)
+        return;
+
+    if (!vo_update_osd(g_image_width, g_image_height))
+        return;
+
+    if (!vo_osd_check_range_update(0, 0, g_image_width, g_image_height)) {
+        disable_osd();
+        return;
+    }
+
+    status = vaMapBuffer(va_context->display, va_osd_image.buf,
+                         &va_osd_image_data);
+    if (!check_status(status, "vaMapBuffer()"))
+        return;
+
+    memset(va_osd_image_data, 0, va_osd_image.data_size);
+
+    set_osd_image_dirty_rect(0, 0, g_image_width, g_image_height);
+    vo_draw_text(g_image_width, g_image_height, va_osd_draw_alpha);
+
+    status = vaUnmapBuffer(va_context->display, va_osd_image.buf);
+    if (!check_status(status, "vaUnmapBuffer()"))
+        return;
+    va_osd_image_data = NULL;
+
+    enable_osd(&va_osd_image_dirty_rect, &va_osd_image_dirty_rect);
+}
+
+static void flip_page(void)
+{
+    VASurfaceID surface;
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] flip_page()\n");
+
+    surface = g_output_surfaces[g_output_surface];
+    if (surface != VA_INVALID_SURFACE)
+        put_surface(surface);
+    g_output_surface = (g_output_surface + 1) % MAX_OUTPUT_SURFACES;
+
+#if CONFIG_VAAPI_GLX
+    if (gl_enabled && surface != VA_INVALID_SURFACE)
+        flip_page_glx();
+#endif
+}
+
+static VASurfaceID *get_surface(mp_image_t *mpi)
+{
+    VASurfaceID *surface;
+
+    if (is_direct_mapping()) {
+        assert(mpi->number < va_num_surfaces);
+        surface = va_free_surfaces[mpi->number];
+        return surface;
+    }
+
+    /* Push current surface to a free slot */
+    if (mpi->priv) {
+        assert(!va_free_surfaces[va_free_surfaces_tail_index]);
+        va_free_surfaces[va_free_surfaces_tail_index] = mpi->priv;
+        va_free_surfaces_tail_index = (va_free_surfaces_tail_index + 1) % va_num_surfaces;
+    }
+
+    /* Pop the least recently used free surface */
+    assert(va_free_surfaces[va_free_surfaces_head_index]);
+    surface = va_free_surfaces[va_free_surfaces_head_index];
+    va_free_surfaces[va_free_surfaces_head_index] = NULL;
+    va_free_surfaces_head_index = (va_free_surfaces_head_index + 1) % va_num_surfaces;
+    return surface;
+}
+
+static uint32_t get_image(mp_image_t *mpi)
+{
+    VASurfaceID *surface;
+
+    if (mpi->type != MP_IMGTYPE_NUMBERED)
+        return VO_FALSE;
+
+    if (!IMGFMT_IS_VAAPI(g_image_format))
+        return VO_FALSE;
+
+    surface = get_surface(mpi);
+    if (!surface)
+        return VO_FALSE;
+
+    mpi->flags |= MP_IMGFLAG_DIRECT;
+    mpi->stride[0] = mpi->stride[1] = mpi->stride[2] = mpi->stride[3] = 0;
+    mpi->planes[0] = mpi->planes[1] = mpi->planes[2] = mpi->planes[3] = NULL;
+    mpi->planes[0] = mpi->planes[3] = (char *)(uintptr_t)*surface;
+    mpi->num_planes = 1;
+    mpi->priv = surface;
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] get_image(): surface 0x%08x\n", *surface);
+
+    return VO_TRUE;
+}
+
+static uint32_t draw_image(mp_image_t *mpi)
+{
+    VASurfaceID surface = (uintptr_t)mpi->planes[3];
+
+    mp_msg(MSGT_VO, MSGL_DBG2, "[vo_vaapi] draw_image(): surface 0x%08x\n", surface);
+
+    g_output_surfaces[g_output_surface] = surface;
+
+    if (cpu_stats) {
+        static uint64_t ticks;
+        if ((ticks++ % 30) == 0) {
+            cpu_frequency = get_cpu_frequency();
+            cpu_usage = get_cpu_usage(CPU_USAGE_QUANTUM);
+        }
+    }
+    return VO_TRUE;
+}
+
+static void check_events(void)
+{
+    int events = vo_x11_check_events(mDisplay);
+
+    if (events & VO_EVENT_RESIZE)
+        resize();
+
+    if ((events & (VO_EVENT_EXPOSE|VO_EVENT_RESIZE)) && g_is_paused) {
+        VASurfaceID surface = g_output_surfaces[g_output_surface];
+        if (surface != VA_INVALID_SURFACE)
+            put_surface(surface);
+    }
+}
+
+static int control(uint32_t request, void *data, ...)
+{
+    switch (request) {
+    case VOCTRL_PAUSE:
+        return (g_is_paused = 1);
+    case VOCTRL_RESUME:
+        return (g_is_paused = 0);
+    case VOCTRL_QUERY_FORMAT:
+        return query_format(*((uint32_t *)data));
+    case VOCTRL_GET_IMAGE:
+        return get_image(data);
+    case VOCTRL_DRAW_IMAGE:
+        return draw_image(data);
+    case VOCTRL_GUISUPPORT:
+        return VO_TRUE;
+    case VOCTRL_BORDER:
+        vo_x11_border();
+        resize();
+        return VO_TRUE;
+    case VOCTRL_FULLSCREEN:
+        vo_x11_fullscreen();
+        resize();
+        return VO_TRUE;
+    case VOCTRL_ONTOP:
+        vo_x11_ontop();
+        return VO_TRUE;
+    case VOCTRL_GET_PANSCAN:
+        return VO_TRUE;
+    case VOCTRL_SET_PANSCAN:
+        resize();
+        return VO_TRUE;
+    case VOCTRL_GET_HWACCEL_CONTEXT:
+        *((void **)data) = va_context;
+        return VO_TRUE;
+    }
+    return VO_NOTIMPL;
+}
